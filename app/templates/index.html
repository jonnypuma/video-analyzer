<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Analyzer | HDR Intelligence</title>
    <link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}">
    <script src="{{ url_for('static', filename='chart.js') }}"></script>
    <style>
        :root {
            /* Palette */
            --col-fel: #a55eea;
            --col-mel: #5f27cd;
            --col-p5: #27ae60;
            --col-p8: #e74c3c;
            --col-p84: #fd79a8;
            --col-10p: #f1c40f;
            --col-10: #e67e22;
            --col-hlg: #3498db;
            --col-sdr: #555555;
            --col-fail: #ff0000;
            --bg-dark: #0a0a0a;
            --bg-panel: #151515;
            --border: #333;
        }

        body {
            background: var(--bg-dark);
            color: white;
            font-family: 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            overflow-x: hidden;
            scroll-behavior: smooth;
        }

        .container {
            max-width: 95vw;
            margin: auto;
            padding: 30px;
        }
        
        @media (min-width: 1920px) {
            .container {
                max-width: 98vw;
            }
        }
        
        @media (min-width: 2560px) {
            .container {
                max-width: 99vw;
            }
        }

        /* --- UTILS --- */
        .spinner {
            display: inline-block; width: 12px; height: 12px;
            border: 2px solid rgba(52, 152, 219, 0.3); border-radius: 50%;
            border-top-color: #3498db; animation: spin 1s ease-in-out infinite;
            vertical-align: middle; margin-left: 10px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .hidden { display: none !important; }

        /* --- SETTINGS INPUTS (NUCLEAR OPTION FOR ARROWS) --- */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
            display: none; /* Force hidden */
        }
        input[type=number] { -moz-appearance: textfield; appearance: textfield; }

        /* --- SETTINGS TOGGLE ANIMATION --- */
        .settings-toggle {
            cursor: pointer; width: 45px; height: 45px; flex-shrink: 0;
            display: flex; align-items: center; justify-content: center; margin-right: 15px;
        }
        .settings-toggle svg { width: 100%; height: 100%; transition: transform 500ms cubic-bezier(0.4, 0, 0.2, 1); }
        .settings-toggle.active svg { transform: rotate(90deg); }
        .settings-toggle path { transition: transform 500ms cubic-bezier(0.4, 0, 0.2, 1), stroke-dasharray 500ms cubic-bezier(0.4, 0, 0.2, 1), stroke-dashoffset 500ms cubic-bezier(0.4, 0, 0.2, 1); }
        .settings-toggle path:nth-child(1) { transform-origin: 36% 40%; }
        .settings-toggle path:nth-child(2) { stroke-dasharray: 29 299; }
        .settings-toggle path:nth-child(3) { transform-origin: 35% 63%; }
        .settings-toggle path:nth-child(4) { stroke-dasharray: 29 299; }
        .settings-toggle path:nth-child(5) { transform-origin: 61% 52%; }
        .settings-toggle path:nth-child(6) { transform-origin: 62% 52%; }
        .settings-toggle.active path:nth-child(1) { transform: translateX(9px) translateY(1px) rotate(45deg); }
        .settings-toggle.active path:nth-child(2) { stroke-dasharray: 225 299; stroke-dashoffset: -72px; }
        .settings-toggle.active path:nth-child(3) { transform: translateX(9px) translateY(1px) rotate(-45deg); }
        .settings-toggle.active path:nth-child(4) { stroke-dasharray: 225 299; stroke-dashoffset: -72px; }
        .settings-toggle.active path:nth-child(5) { transform: translateX(9px) translateY(1px) rotate(-45deg); }
        .settings-toggle.active path:nth-child(6) { transform: translateX(9px) translateY(1px) rotate(45deg); }

        /* --- HEADER --- */
        #scan-info-box { display: flex; align-items: center; font-size: 0.85em; opacity: 0.8; font-weight: bold; text-transform: uppercase; color: #3498db; cursor: pointer; transition: opacity 0.2s; }
        #scan-info-box:hover { opacity: 1; text-decoration: underline; }

        /* --- RIBBON --- */
        .summary-ribbon { display: grid; grid-template-columns: repeat(13, 1fr); gap: 10px; margin-bottom: 20px; }
        .stat-card {
            background: var(--bg-panel); border-radius: 12px; padding: 15px; border: 1px solid #222;
            text-align: center; transition: transform 0.2s; cursor: pointer; user-select: none;
        }
        .stat-card:hover { transform: translateY(-3px); background: #1a1a1a; border-color: #555; }
        .stat-label { font-size: 0.65em; opacity: 0.6; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; font-weight: bold; }
        .stat-value { font-size: 1.4em; font-weight: 800; font-variant-numeric: tabular-nums; }
        #stat-duration { font-family: 'Consolas', 'Monaco', monospace; letter-spacing: -1px; }

        /* --- CONTROL STACK & BUTTON --- */
        .control-stack { display: grid; grid-template-columns: auto 1fr; gap: 15px; margin-bottom: 20px; height: 62px; }
        .action-panel, .automation-bar, #progress-container {
            height: 100%; display: flex; align-items: center; box-sizing: border-box;
            background: #0f0f0f; border: 1px solid #222; border-radius: 12px; padding: 0 10px;
        }
        .action-panel { gap: 10px; }
        .automation-bar { z-index: 2; opacity: 1; visibility: visible; transition: opacity 800ms, visibility 800ms; padding: 10px 15px; overflow: hidden; }

        button { border-radius: 8px; font-weight: bold; cursor: pointer; border: none; color: white; transition: all 0.2s ease; }
        button:hover { filter: brightness(1.15); transform: scale(1.02); }
        button:active { transform: scale(0.98); }

        #main-action-wrapper, #btn-export, #btn-toggle-charts, #btn-save { width: 140px; height: 40px; box-sizing: border-box; flex-shrink: 0; display: flex; align-items: center; justify-content: center; }
        #main-action-wrapper { position: relative; }
        #scan-group { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; transition: opacity 0.3s ease, visibility 0.3s; box-sizing: border-box; z-index: 20; }
        #btn-scan { background: #3498db; }
        #btn-delete-action { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; transition: opacity 0.3s ease, visibility 0.3s; box-sizing: border-box; background: #e74c3c; opacity: 0; visibility: hidden; z-index: 10; }
        .selection-active #scan-group { opacity: 0; visibility: hidden; z-index: 10; }
        .selection-active #btn-delete-action { opacity: 1; visibility: visible; z-index: 20; }
        
        #btn-abort { display: none; width: 140px; height: 40px; justify-content: center; align-items: center; background: #e74c3c; box-sizing: border-box; }
        body.scanning #main-action-wrapper { display: none !important; }
        body.scanning #btn-abort { display: inline-flex; }

        .btn-green { background: #27ae60; }
        .btn-grey { background: #333; }
        .btn-blue { background: #3498db; }
        .btn-red { background: #e74c3c; }
        .btn-orange { background: #e67e22 !important; }
        #btn-save { background: #3498db; }

        .right-anchored { margin-left: auto; display: flex; align-items: center; gap: 15px; flex-shrink: 0; }
        .status-stack { position: relative; flex-grow: 1; height: 100%; }
        #progress-container { position: absolute; top: 0; left: 0; width: 100%; background: #111; overflow: hidden; z-index: 1; opacity: 0; visibility: hidden; padding: 0; border: 1px solid #333; }
        body.scanning .automation-bar { opacity: 0; visibility: hidden; transition-delay: 0ms; }
        body.scanning #progress-container { opacity: 1; visibility: visible; z-index: 3; transition-delay: 800ms; }
        #progress-bar { height: 100%; background: linear-gradient(90deg, #2ecc71, #27ae60); width: 0%; transition: width 0.4s ease; }
        #progress-text { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-weight: 900; text-shadow: 0 1px 3px #000; }

        .sched-group, .filter-group { display: flex; gap: 10px; align-items: center; flex: 1; min-width: 0; flex-wrap: nowrap; overflow-x: auto; }
        .filter-group::-webkit-scrollbar { height: 4px; }
        .filter-group::-webkit-scrollbar-track { background: #222; }
        .filter-group::-webkit-scrollbar-thumb { background: #555; border-radius: 2px; }
        .filter-group::-webkit-scrollbar-thumb:hover { background: #777; }
        input, select { padding: 0 12px; border-radius: 8px; border: 1px solid #333; background: #000; color: #fff; height: 38px; box-sizing: border-box; }

        /* --- DASHBOARD --- */
        .dashboard { display: none; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 30px; animation: slideDown 0.4s ease-out; }
        .chart-box { background: var(--bg-panel); border-radius: 12px; padding: 20px; border: 1px solid #222; height: 260px; position: relative; }
        canvas { position: relative; z-index: 1; }
        .chart-title-overlay { position: absolute; top: 15px; left: 20px; color: white; font-weight: bold; font-size: 14px; z-index: 10; font-family: 'Segoe UI', sans-serif; text-transform: uppercase; letter-spacing: 0.5px; }
        .chart-toggle-btn { position: absolute; top: 15px; right: 15px; cursor: pointer; color: #666; font-size: 1.4em; z-index: 20; transition: all 0.3s ease; user-select: none; }
        .chart-toggle-btn:hover { color: #3498db; transform: rotate(180deg); }
        .chart-mode-toggle {
            position: absolute; bottom: 12px; left: 12px; z-index: 20;
            background: #111; border: 1px solid #333; border-radius: 12px;
            padding: 4px 10px; font-size: 0.75em; color: #ccc; cursor: pointer;
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        .chart-mode-toggle:hover { border-color: #3498db; color: #fff; }
        .chart-view { width: 100%; height: 100%; position: absolute; top: 0; left: 0; padding: 20px; box-sizing: border-box; background: var(--bg-panel); border-radius: 12px; }
        .chart-view.hidden { opacity: 0; z-index: -1; visibility: hidden; }
        .chart-view.active { opacity: 1; z-index: 1; visibility: visible; transition: opacity 0.4s ease; }
        .vol-header { position: absolute; top: 15px; right: 15px; z-index: 10; display: flex; align-items: center; gap: 8px; }
        .vol-header select { height: 28px; font-size: 0.8em; padding: 0 5px; width: 130px; background: rgba(0,0,0,0.6); border: 1px solid #444; color: #ccc; }
        .vol-header span { font-size: 0.7em; font-weight: bold; color: #666; text-transform: uppercase; }

        /* --- TABLE --- */
        .table-wrap { background: #111; border-radius: 12px; overflow: hidden; border: 1px solid #222; position: relative; }
        .table-scroll { overflow-x: auto; overflow-y: hidden; }
        table { width: max-content; border-collapse: collapse; table-layout: fixed; min-width: 100%; max-width: none; }
        thead { border-bottom: none; margin: 0; padding: 0; }
        th.col-chk, td.col-chk {
            position: sticky; left: 0; z-index: 6; background: #111;
        }
        th.col-del, td.col-del {
            position: sticky; right: 0; z-index: 6; background: #111;
        }
        th.col-chk { z-index: 7; }
        th.col-del { z-index: 7; }
        .header-scrollbar-panel {
            position: absolute; left: 0; right: 0; height: 10px; z-index: 6; pointer-events: none;
        }
        .header-scrollbar {
            height: 10px; overflow-x: auto; overflow-y: hidden;
            background: #0f0f0f; border: 1px solid #222; border-radius: 6px;
            pointer-events: auto;
        }
        .header-scrollbar-inner { height: 1px; }
        tbody { margin-top: 0; padding-top: 0; }
        th { background: #1f1f1f; padding: 8px 5px 0px 5px; text-align: left; color: #3498db; font-size: 0.88em; text-transform: uppercase; cursor: default; user-select: none; position: relative; vertical-align: top; margin: 0; border-bottom: none; box-sizing: border-box; }
        th[onclick] { cursor: pointer; }
        th.col-chk, th.col-del { cursor: default !important; }
        th:hover { color: white; background: #2a2a2a; }
        th .th-header-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px; }
        th .th-header-row span { color: #3498db; font-size: 0.88em; }
        th:hover .th-header-row span { color: white; }
        th .th-filter-row { margin-top: 4px; margin-bottom: 0px; }
        th .th-filter-row * { pointer-events: auto; }
        th .th-filter-row select, th .th-filter-row input[type="text"] { 
            width: 100%; padding: 0 12px; border-radius: 8px; border: 1px solid #333; 
            background: #000; color: #fff; height: 38px; box-sizing: border-box;
            font-size: 0.9em; cursor: pointer; font-family: 'Segoe UI', Roboto, sans-serif;
            margin-bottom: 0;
        }
        th .th-filter-row select option {
            background: #1a1a1a !important; color: #fff !important; font-size: 0.9em !important; padding: 8px 12px;
            font-family: 'Segoe UI', Roboto, sans-serif !important;
            font-weight: normal !important;
            line-height: normal !important;
        }
        th .th-filter-row select:hover, th .th-filter-row input[type="text"]:hover {
            border-color: #555;
        }
        th .th-filter-row select:focus, th .th-filter-row input[type="text"]:focus {
            border-color: #3498db; outline: none;
        }
        th .th-filter-row input[type="text"] {
            cursor: text;
        }
        td { padding: 12px 15px; border-bottom: 1px solid #1a1a1a; font-size: 0.88em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; vertical-align: middle; box-sizing: border-box; }
        /* Override padding for specific columns to keep them narrow */
        td.col-chk { padding: 4px 2px !important; }
        td.col-del { padding: 4px 2px !important; }
        tr:hover td { background: #161616; }
        .td-center { text-align: center; } th.td-center { text-align: center; }
        .sort-icon { display: inline-block; margin-left: 5px; color: #3498db; font-size: 1.2em; vertical-align: bottom; }

        /* Columns */
        .col-chk { width: 40px !important; min-width: 40px !important; max-width: 40px !important; text-align: center; cursor: default !important; border-right: 1px solid #333; }
        
        /* Column Resize */
        th[class*="col-"]:not(.col-chk):not(.col-del) {
            position: relative;
        }
        th[class*="col-"]:not(.col-chk):not(.col-del)::after {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            cursor: col-resize;
            background: transparent;
        }
        th[class*="col-"]:not(.col-chk):not(.col-del):hover::after {
            background: #3498db;
        }
        th.col-chk, td.col-chk { 
            width: 40px !important; 
            min-width: 40px !important; 
            max-width: 40px !important; 
            padding: 1px !important;
            box-sizing: border-box;
            vertical-align: middle !important;
        }
        th.col-chk {
            padding: 4px 1px !important;
            vertical-align: middle !important;
        }
        .col-file { width: 18%; } 
        .col-hyb, .col-res, .col-bit, .col-vol { width: 5%; } 
        .col-main, .col-prof, .col-sec { width: 7%; } 
        .col-scan, .col-stat { width: 5%; } 
        .col-size { width: 6%; }
        .col-width, .col-height { width: 4%; }
        .col-cont { width: 4%; }
        .col-del { width: 40px !important; min-width: 40px !important; max-width: 40px !important; cursor: default !important; position: sticky !important; right: 0 !important; background: #1f1f1f !important; z-index: 10 !important; }
        th.col-del, td.col-del { 
            width: 40px !important; 
            min-width: 40px !important; 
            max-width: 40px !important;
            padding: 0px !important;
            position: sticky !important;
            right: 0 !important;
            background: #1f1f1f !important;
            z-index: 10 !important;
            box-sizing: border-box;
            overflow: visible;
            border-left: 1px solid #333;
        }
        th.col-del {
            padding: 0 !important;
            vertical-align: top !important;
            position: relative;
            z-index: 101;
        }

        /* Hide Classes */
        .hide-col-hyb .col-hyb { display: none; }
        .hide-col-main .col-main { display: none; }
        .hide-col-prof .col-prof { display: none; }
        .hide-col-sec .col-sec { display: none; }
        .hide-col-res .col-res { display: none; }
        .hide-col-stat .col-stat { display: none; }
        .hide-col-size .col-size { display: none; }
        .hide-col-width .col-width { display: none; }
        .hide-col-height .col-height { display: none; }
        .hide-col-bit .col-bit { display: none; }
        .hide-col-scan .col-scan { display: none; }
        .hide-col-vol .col-vol { display: none; }
        .hide-col-cont .col-cont { display: none; }
        .hide-col-cont .col-cont { display: none; }
        .hide-col-audio .col-audio { display: none; }
        .hide-col-sub .col-sub { display: none; }
        .hide-col-cll .col-cll { display: none; }
        .hide-col-fall .col-fall { display: none; }
        .hide-col-el .col-el { display: none; }
        .hide-col-video-source .col-video-source { display: none; }
        .hide-col-source-format .col-source-format { display: none; }
        .hide-col-video-codec .col-video-codec { display: none; }
        .hide-col-is-3d .col-is-3d { display: none; }
        .hide-col-edition .col-edition { display: none; }
        .hide-col-year .col-year { display: none; }
        .hide-col-media-type .col-media-type { display: none; }
        .hide-col-show-title .col-show-title { display: none; }
        .hide-col-season .col-season { display: none; }
        .hide-col-episode .col-episode { display: none; }
        .hide-col-movie-title .col-movie-title { display: none; }
        .hide-col-episode-title .col-episode-title { display: none; }
        
        .col-audio { width: 10%; }
        .col-sub { width: 5%; }
        .col-cll { width: 6%; }
        .col-fall { width: 6%; }
        .col-el { width: 5%; }
        .col-video-source { width: 6%; }
        .col-source-format { width: 6%; }
        .col-video-codec { width: 5%; }
        .col-is-3d { width: 4%; }
        .col-edition { width: 7%; }
        .col-year { width: 4%; }
        .col-media-type { width: 5%; }
        .col-show-title { width: 10%; }
        .col-season { width: 4%; }
        .col-episode { width: 4%; }
        .col-movie-title { width: 10%; }
        .col-episode-title { width: 10%; }
        td.col-cll, td.col-fall { font-family: monospace; }

        /* Column Menu */
        .col-toggle-menu {
            position: absolute; top: 0; left: 0; right: 40px; height: 85px; background: #1f1f1f; border-bottom: 1px solid #333; border-left: 1px solid #333;
            display: flex; align-items: center; justify-content: flex-start; gap: 0; z-index: 50; box-sizing: border-box;
            transform: translateY(-100%); transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            overflow: hidden;
        }
        .col-toggle-menu.active { transform: translateY(0); }
        
        .col-menu-left-panel {
            display: flex; align-items: center; gap: 10px; padding-left: 15px; padding-right: 10px; background: #1f1f1f; flex-shrink: 0;
        }
        
        .col-menu-label {
            color: #3498db; font-weight: bold; font-size: 0.9em; margin-right: 5px; 
        }
        
        .col-menu-scrollable {
            display: flex; align-items: center; gap: 10px; flex: 1; overflow-x: auto; scrollbar-width: none; padding: 0 10px;
            min-width: 0;
            margin-right: 0;
            max-width: 100%;
        }
        .col-menu-scrollable::-webkit-scrollbar { display: none; }
        
        .col-menu-right-panel {
            display: flex; align-items: center; padding: 0 10px; background: #1f1f1f; flex-shrink: 0; position: absolute; right: 0; z-index: 51; height: 100%;
            pointer-events: auto;
        }
        
        /* Hamburger Button - Inside col-del header */
        .col-del #burger-btn {
            width: 100%; 
            height: 100%;
            min-height: 85px;
            cursor: pointer; 
            background: #1f1f1f; 
            z-index: 100;
            border-left: 1px solid #333; 
            border-top-right-radius: 11px;
            display: flex; 
            align-items: center; 
            justify-content: center;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        .col-del #burger-btn:hover { background: #2a2a2a; }
        /* Ensure trash buttons in col-del are visible and properly aligned */
        td.col-del {
            text-align: center;
            padding: 8px 0px !important;
        }

        .settings-toggle.table-mode { 
            width: 45px; height: 45px; margin: 0 auto; display: flex; 
        }
        .settings-toggle.table-mode svg { 
            width: 100%; height: 100%; transition: transform 500ms cubic-bezier(0.4, 0, 0.2, 1); 
        }
        .settings-toggle.table-mode.active svg { transform: rotate(90deg); }
        .settings-toggle.table-mode path { 
            transition: transform 500ms cubic-bezier(0.4, 0, 0.2, 1), stroke-dasharray 500ms cubic-bezier(0.4, 0, 0.2, 1), stroke-dashoffset 500ms cubic-bezier(0.4, 0, 0.2, 1); 
        }
        .settings-toggle.table-mode path:nth-child(1) { transform-origin: 36% 40%; }
        .settings-toggle.table-mode path:nth-child(2) { stroke-dasharray: 29 299; }
        .settings-toggle.table-mode path:nth-child(3) { transform-origin: 35% 63%; }
        .settings-toggle.table-mode path:nth-child(4) { stroke-dasharray: 29 299; }
        .settings-toggle.table-mode path:nth-child(5) { transform-origin: 61% 52%; }
        .settings-toggle.table-mode path:nth-child(6) { transform-origin: 62% 52%; }
        .settings-toggle.table-mode.active path:nth-child(1) { transform: translateX(9px) translateY(1px) rotate(45deg); }
        .settings-toggle.table-mode.active path:nth-child(2) { stroke-dasharray: 225 299; stroke-dashoffset: -72px; }
        .settings-toggle.table-mode.active path:nth-child(3) { transform: translateX(9px) translateY(1px) rotate(-45deg); }
        .settings-toggle.table-mode.active path:nth-child(4) { stroke-dasharray: 225 299; stroke-dashoffset: -72px; }
        .settings-toggle.table-mode.active path:nth-child(5) { transform: translateX(9px) translateY(1px) rotate(-45deg); }
        .settings-toggle.table-mode.active path:nth-child(6) { transform: translateX(9px) translateY(1px) rotate(45deg); }
        .col-toggle-item { display: flex; align-items: center; gap: 6px; font-size: 0.75em; color: #ccc; cursor: pointer; user-select: none; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px; white-space: nowrap; }
        .col-toggle-item:hover { color: white; }
        
        /* Main Menu */
        .main-menu {
            position: relative; height: 0; background: #1f1f1f; border-bottom: 1px solid #333;
            display: flex; align-items: center; justify-content: flex-start; gap: 0; z-index: 99; box-sizing: border-box;
            overflow: hidden; transition: height 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            margin-bottom: 0;
        }
        .main-menu.active { height: 60px; margin-bottom: 20px; }
        
        .main-menu-left-panel {
            display: none; /* Hide left panel label for main menu */
        }
        
        .main-menu-label {
            color: #3498db; font-weight: bold; font-size: 0.9em; margin-right: 5px;
        }
        
        .main-menu-content {
            display: flex; align-items: center; gap: 10px; padding: 0 15px; width: 100%; min-height: 60px;
        }
        
        .main-menu-section {
            display: flex; align-items: center; gap: 10px;
        }
        
        .main-menu-section-label {
            color: #888; font-size: 0.8em; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px;
        }
        
        /* New: Scroll Buttons inside Column Menu */
        .col-scroll-btn {
            background: #333; color: white; border: 1px solid #555; width: 30px; height: 30px; 
            border-radius: 50%; display: flex; align-items: center; justify-content: center; 
            cursor: pointer; font-size: 0.9em; flex-shrink: 0;
            transition: background 0.2s ease, border-color 0.2s ease;
        }
        .col-scroll-btn:hover { background: #3498db; border-color: #3498db; }
        
        input[type="checkbox"] {
            appearance: none; -webkit-appearance: none; width: 18px; height: 18px; border: 2px solid #555; border-radius: 4px; background: #222;
            cursor: pointer; position: relative; display: inline-block; vertical-align: middle; margin: 0; outline: none;
        }
        input[type="checkbox"]:checked {
            background: #3498db; border-color: #3498db;
        }
        input[type="checkbox"]:checked::after {
            content: '✓'; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 14px; font-weight: bold; line-height: 1;
        }
        .row-chk:checked { background-color: #3498db; border-color: #3498db; }
        .row-chk:checked::after { content: '✔'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 12px; color: white; line-height: 1; }

        /* Row selection for keyboard navigation */
        tr.keyboard-selected td { background: #173a5e !important; }
        tr.keyboard-selected { outline: 2px solid #2e8bff; outline-offset: -2px; }
        tr.keyboard-selected:hover td { background: #173a5e !important; }
        #video-table-body::before { content: ""; display: block; height: 14px; }
        
        .col-chk-input:checked { background-color: #27ae60; border-color: #27ae60; }
        .col-chk-input:checked::after { content: '✔'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 12px; color: white; line-height: 1; }

        .vol-chk:checked { background-color: #3498db; border-color: #3498db; }
        .vol-chk:checked::after { content: '✔'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 12px; color: white; line-height: 1; }
        
        .set-chk:checked { background-color: #e67e22; border-color: #e67e22; }
        .set-chk:checked::after { content: '✔'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 12px; color: white; line-height: 1; }

        #master-chk { width: 18px !important; height: 18px !important; flex-shrink: 0 !important; max-width: 18px !important; min-width: 18px !important; }
        #master-chk.master-dash { background-color: #e67e22; border-color: #e67e22; }
        #master-chk.master-dash::after { content: ""; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 10px; height: 2px; background: white; }
        #master-chk.master-x { background-color: #e74c3c; border-color: #e74c3c; }
        #master-chk.master-x::after { content: "✕"; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 12px; color: white; font-weight: bold; line-height: 1; }

        .trash-btn { background: none; border: none; color: #555; cursor: pointer; font-size: 1.2em; display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; }
        .trash-btn:hover { color: #e74c3c; }

        .badge { padding: 3px 8px; border-radius: 4px; font-size: 0.8em; font-weight: bold; text-transform: uppercase; display: inline-block; transition: transform 0.1s; cursor: pointer; }
        .badge:hover { transform: scale(1.1); filter: brightness(1.2); }
        .badge-p7-fel { background: var(--col-fel); border: 1px solid #dcc6e0; }
        .badge-p7-mel { background: var(--col-mel); }
        .badge-p5 { background: var(--col-p5); }
        .badge-p8 { background: var(--col-p8); }
        .badge-p84 { background: var(--col-p84); color: black; }
        .badge-dovi { background: #555; } 
        .badge-hdr10plus { background: var(--col-10p); color: black; }
        .badge-hdr10 { background: var(--col-10); }
        .badge-hlg { background: var(--col-hlg); }
        .badge-sdr_only { background: var(--col-sdr); }
        .badge-fail { background: var(--col-fail); color: white; cursor: help; }
        .badge-ok { background: #27ae60; color: white; }

        .console-wrap { background: #0c0c0c; border-radius: 12px; border: 1px solid #333; margin-top: 20px; overflow: hidden; position: relative; }
        .console-header { background: #1a1a1a; padding: 10px 15px; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center; font-size: 0.72em; font-weight: bold; color: #888; }
        #debug-console { height: 200px; overflow-y: auto; font-family: 'Consolas', monospace; font-size: 0.82rem; padding: 15px; color: #ccc; line-height: 1.5; }
        .log-success { color: #2ecc71; }
        .log-err { color: #e74c3c; }
        .log-default { color: #ccc; }
        
        /* Multiselect Dropdown Styles */
        .multiselect-wrapper { position: relative; width: 100%; }
        .multiselect-button { 
            width: 100%; padding: 0 12px; border-radius: 8px; border: 1px solid #333; 
            background: #000; color: #fff; height: 38px; box-sizing: border-box;
            display: flex; align-items: center; justify-content: space-between; cursor: pointer;
            font-size: 0.9em;
            gap: 8px; overflow: hidden;
        }
        .multiselect-button span:first-child {
            flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        .multiselect-button:hover { border-color: #555; }
        .multiselect-button.active { border-color: #3498db; }
        .multiselect-arrow { transition: transform 0.2s; }
        .multiselect-button.active .multiselect-arrow { transform: rotate(180deg); }
        .multiselect-dropdown {
            position: absolute; top: 100%; left: 0; z-index: 1000;
            background: #1a1a1a; border: 1px solid #333; border-radius: 8px;
            margin-top: 4px; max-height: 250px; overflow-y: auto; display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            min-width: 200px; width: max-content; max-width: 400px;
            white-space: nowrap;
        }
        .multiselect-dropdown.active { display: block; }
        .multiselect-option {
            padding: 8px 12px; display: flex; align-items: center; gap: 8px;
            cursor: pointer; transition: background 0.15s;
        }
        .multiselect-option:hover { background: #2a2a2a; }
        .multiselect-option input[type="checkbox"] {
            width: 18px; height: 18px; cursor: pointer; margin: 0;
            accent-color: #3498db;
            flex-shrink: 0;
            appearance: checkbox;
            -webkit-appearance: checkbox;
            -moz-appearance: checkbox;
        }
        .multiselect-option input[type="checkbox"]:checked {
            accent-color: #3498db;
        }
        .multiselect-option label { cursor: pointer; flex: 1; user-select: none; margin-left: 4px; font-size: 0.9em; font-family: 'Segoe UI', Roboto, sans-serif; font-weight: normal; }
        .multiselect-divider {
            border-top: 1px solid #2a2a2a; margin: 4px 0;
        }
        
        .go-top-link { cursor: pointer; margin-right: 15px; color: #888; text-decoration: none; }
        .go-top-link:hover { color: white; }
        
        .res-icon-wrapper { display: inline-block; cursor: pointer; }
        .res-icon-wrapper img { height: 28px; width: auto; vertical-align: middle; transition: transform 0.2s; }
        .res-icon-wrapper img:hover { transform: scale(1.1); }
        
        /* Volume Selection Modal Styles */
        .vol-list { text-align: left; max-height: 300px; overflow-y: auto; margin: 20px 0; border: 1px solid #333; border-radius: 8px; padding: 10px; background: #000; }
        .folder-browser { display: grid; grid-template-columns: 220px 1fr; gap: 12px; }
        .folder-list { text-align: left; max-height: 260px; overflow-y: auto; border: 1px solid #333; border-radius: 8px; padding: 10px; background: #000; }
        .folder-row { display: flex; align-items: center; justify-content: space-between; gap: 8px; padding: 6px 8px; border-bottom: 1px solid #1a1a1a; }
        .folder-row:last-child { border-bottom: none; }
        .folder-row.muted { opacity: 0.5; }
        .folder-path { font-size: 0.85em; color: #bbb; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .folder-actions { display: flex; gap: 6px; }
        .folder-item-btn { padding: 3px 8px; font-size: 0.75em; }
        .folder-remove-btn { font-weight: 800; font-size: 0.95em; line-height: 1; text-shadow: 0 0 2px rgba(0,0,0,0.9); }
        .folder-type-select { background: #111; color: #ddd; border: 1px solid #333; border-radius: 6px; padding: 2px 6px; font-size: 0.75em; }
        .btn-group-scan { display: inline-flex; align-items: center; width: 100%; height: 100%; }
        .btn-scan-main { border-top-right-radius: 0; border-bottom-right-radius: 0; flex: 1; height: 100%; background: #3498db; display: flex; flex-direction: column; justify-content: center; line-height: 1.1; }
        .btn-scan-toggle { border-top-left-radius: 0; border-bottom-left-radius: 0; padding: 0 10px; height: 100%; background: #3498db; }
        .scan-dropdown { position: absolute; top: 100%; left: 0; margin-top: 6px; background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 6px 0; min-width: 160px; z-index: 200; display: none; }
        .scan-dropdown.active { display: block; }
        .scan-dropdown button { width: 100%; background: transparent; border: none; color: #ddd; text-align: left; padding: 6px 12px; cursor: pointer; }
        .scan-dropdown button:hover { background: #2a2a2a; color: #fff; }
        .scan-menu-item { position: relative; }
        .scan-menu-item::after {
            content: ""; position: absolute; top: 0; right: -8px; width: 8px; height: 100%;
        }
        .scan-menu-label { padding: 6px 12px; cursor: pointer; color: #ddd; }
        .scan-menu-label:hover { background: #2a2a2a; color: #fff; }
        .scan-submenu { position: absolute; top: 0; left: 100%; margin-left: 6px; background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 6px 0; min-width: 220px; display: none; }
        .scan-menu-item:hover .scan-submenu { display: block; }
        .scan-submenu:hover { display: block; }
        .scan-target-sub { font-size: 0.7em; color: #e0e0e0; opacity: 0.9; }
        .context-menu {
            position: absolute; background: #1a1a1a; border: 1px solid #333; border-radius: 8px;
            padding: 6px 0; min-width: 180px; z-index: 300; display: none;
            box-shadow: 0 6px 18px rgba(0,0,0,0.4);
        }
        .context-menu.active { display: block; }
        .context-menu button { width: 100%; background: transparent; border: none; color: #ddd; text-align: left; padding: 6px 12px; cursor: pointer; }
        .context-menu button:hover { background: #2a2a2a; color: #fff; }
        .context-divider { height: 1px; background: #333; margin: 4px 0; }
        .vol-item { display: flex; align-items: center; padding: 8px; border-bottom: 1px solid #222; cursor: pointer; transition: background 0.15s; }
        .vol-item:hover { background: #161616; }
        .vol-item:last-child { border-bottom: none; }
        .vol-status-dot { width: 10px; height: 10px; border-radius: 50%; margin-right: 10px; flex-shrink: 0; }
        .status-online { background-color: #2ecc71; box-shadow: 0 0 5px #2ecc71; }
        .status-offline { background-color: #e74c3c; box-shadow: 0 0 5px #e74c3c; }
        .vol-name { flex-grow: 1; font-weight: bold; font-size: 0.9em; }
        .vol-chk { margin-left: 10px; transform: scale(1.2); }
        
        /* Modal Base Styles */
        .modal-bg { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); backdrop-filter: blur(5px); }
        .report-content { background: #1a1a1a; width: 450px; margin: 10% auto; padding: 30px; border-radius: 20px; border: 1px solid #3498db; text-align: center; box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        .report-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 25px 0; }
        .report-item { background: #000; padding: 15px; border-radius: 10px; border: 1px solid #222; }
        .warn-content { background: #1a1a1a; width: 400px; margin: 15% auto; padding: 30px; border-radius: 12px; border: 1px solid #e74c3c; text-align: center; }
        
        /* Pulse Animations */
        .pulse-success { animation: pulse-green 1s ease-out; }
        .pulse-error { animation: pulse-red 0.5s ease-in-out; }
        .action-success { background-color: #27ae60 !important; transform: scale(1.05) !important; box-shadow: 0 0 15px rgba(39, 174, 96, 0.5); }
        .action-fail { background-color: #e74c3c !important; animation: pulse-red 0.5s; }

        /* New: Details Modal */
        .details-content { background: #151515; width: 800px; max-height: 80vh; margin: 5% auto; padding: 0; border-radius: 12px; border: 1px solid #3498db; overflow: hidden; display: flex; flex-direction: column; }
        .details-header { padding: 20px; background: #1a1a1a; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center; }
        .details-body { padding: 20px; overflow-y: auto; text-align: left; }
        .details-json { background: #000; padding: 15px; border-radius: 8px; font-family: monospace; color: #2ecc71; white-space: pre-wrap; font-size: 0.85em; }
        
        /* New: Toast */
        #toast-container { position: fixed; bottom: 20px; right: 20px; z-index: 200; }
        .toast { background: #1a1a1a; border-left: 5px solid #2ecc71; color: white; padding: 15px 25px; border-radius: 4px; margin-top: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); opacity: 0; transform: translateY(20px); transition: all 0.3s ease; display: none; }
        .toast.show { opacity: 1; transform: translateY(0); display: block; }

        /* New: Force Rescan */
        .rescan-opt { margin-top: 15px; padding-top: 15px; border-top: 1px solid #333; text-align: left; font-size: 0.9em; color: #e67e22; display: flex; align-items: center; gap: 10px; }
        .rescan-opt input { width: 16px; height: 16px; }

        /* CAROUSEL */
        .controls-wrapper {
            display: flex; align-items: center; background: #1a1a1a; padding: 10px; 
            border-radius: 12px; border: 1px solid #333; gap: 10px; margin-bottom: 10px;
        }
        .filter-carousel {
            display: flex; gap: 10px; overflow-x: auto; white-space: nowrap; scroll-behavior: smooth;
            flex-grow: 1; padding-bottom: 5px; scrollbar-width: none; 
        }
        .filter-carousel::-webkit-scrollbar { display: none; }
        .scroll-btn {
            background: #333; border: 1px solid #555; color: white; 
            width: 30px; height: 38px; border-radius: 50%; cursor: pointer; flex-shrink: 0;
            display: flex; align-items: center; justify-content: center; font-size: 0.9em;
            transition: background 0.2s ease, border-color 0.2s ease;
        }
        .scroll-btn:hover { background: #3498db; border-color: #3498db; }
        .search-wrap { position: relative; width: 540px; flex-shrink: 0; }
        #search-bar { width: 100%; }
        .search-suggestions {
            position: absolute; top: calc(100% + 4px); left: 0; right: 0; z-index: 1000;
            background: #1a1a1a; border: 1px solid #333; border-radius: 8px;
            max-height: 220px; overflow-y: auto; display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        .search-suggestion {
            padding: 8px 12px; cursor: pointer; font-size: 0.85em; color: #ccc;
        }
        .search-suggestion:hover { background: #2a2a2a; }
        .filter-item { width: 130px; flex-shrink: 0; }
        .controls-right { 
            display: flex; gap: 10px; align-items: center; margin-left: 10px; 
            padding-left: 10px; border-left: 1px solid #333; flex-shrink: 0;
        }
        .filter-counter-box { font-size: 0.8em; font-weight: bold; color: #888; text-transform: uppercase; }
    </style>
</head>
<body>
    <div id="details-modal" class="modal-bg">
        <div class="details-content">
            <div class="details-header">
                <h3 style="margin:0; color:#3498db">FILE DETAILS</h3>
                <button class="btn-grey" onclick="closeDetails()">✕</button>
            </div>
            <div class="details-body">
                <p id="det-path" style="color:#888; font-size:0.9em; word-break: break-all; margin-top:0;"></p>
                    <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px;">
                        <span style="color:#888; font-size:0.85em; min-width:80px;">Type</span>
                        <select id="det-media-type" style="width:160px;">
                            <option value="">Auto</option>
                            <option value="movie">Movie</option>
                            <option value="tv">TV</option>
                        </select>
                    </div>
                    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:10px;">
                        <div id="det-show-title-row">
                            <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Show Title</div>
                            <input type="text" id="det-show-title" style="width:100%;">
                        </div>
                        <div id="det-episode-title-row">
                            <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Episode Title</div>
                            <input type="text" id="det-episode-title" style="width:100%;">
                        </div>
                        <div id="det-movie-title-row">
                            <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Movie Title</div>
                            <input type="text" id="det-movie-title" style="width:100%;">
                        </div>
                        <div id="det-season-episode-row" style="display:flex; gap:10px;">
                            <div style="flex:1;">
                                <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Season</div>
                                <input type="number" id="det-season" min="0" style="width:100%;">
                            </div>
                            <div style="flex:1;">
                                <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Episode</div>
                                <input type="number" id="det-episode" min="0" style="width:100%;">
                            </div>
                        </div>
                        <div>
                            <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Year</div>
                            <input type="number" id="det-year" min="1900" max="2099" style="width:100%;">
                        </div>
                        <div>
                            <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Source</div>
                            <input type="text" id="det-video-source" style="width:100%;">
                        </div>
                        <div>
                            <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Source Format</div>
                            <input type="text" id="det-source-format" style="width:100%;">
                        </div>
                        <div>
                            <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Main HDR</div>
                            <input type="text" id="det-main-hdr" style="width:100%;">
                        </div>
                        <div>
                            <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Secondary HDR</div>
                            <input type="text" id="det-secondary-hdr" style="width:100%;">
                        </div>
                    </div>
                <div class="details-json" id="det-json"></div>
            </div>
            <div style="padding: 15px; background: #1a1a1a; border-top: 1px solid #333; display: flex; justify-content: flex-end; gap: 10px;">
                <button class="btn-orange" onclick="rescanFileFromModal()">Rescan File</button>
                <button class="btn-grey" onclick="copyDetails()">Copy JSON</button>
                <button class="btn-blue" onclick="closeDetails()">Close</button>
            </div>
        </div>
    </div>

    <div id="bulk-edit-modal" class="modal-bg">
        <div class="details-content">
            <div class="details-header">
                <h3 style="margin:0; color:#3498db">BULK EDIT</h3>
                <button class="btn-grey" onclick="closeBulkEdit()">✕</button>
            </div>
            <div class="details-body">
                <p style="color:#888; font-size:0.9em; margin-top:0;">
                    Applies changes to <span id="bulk-edit-count">0</span> selected rows. Leave fields blank to keep existing values.
                </p>
                <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px;">
                    <span style="color:#888; font-size:0.85em; min-width:80px;">Type</span>
                    <select id="bulk-media-type" style="width:160px;" autocomplete="off">
                        <option value="">No change</option>
                        <option value="movie">Movie</option>
                        <option value="tv">TV</option>
                    </select>
                    <label style="color:#888; font-size:0.8em; display:flex; align-items:center; gap:6px;">
                        <input type="checkbox" id="bulk-clear-media-type"> Clear
                    </label>
                </div>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:10px;">
                    <div>
                        <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Show Title</div>
                        <input type="text" id="bulk-show-title" style="width:100%;" autocomplete="off">
                        <label style="color:#888; font-size:0.75em; display:flex; align-items:center; gap:6px; margin-top:4px;">
                            <input type="checkbox" id="bulk-clear-show-title"> Clear
                        </label>
                    </div>
                    <div>
                        <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Episode Title</div>
                        <input type="text" id="bulk-episode-title" style="width:100%;" autocomplete="off">
                        <label style="color:#888; font-size:0.75em; display:flex; align-items:center; gap:6px; margin-top:4px;">
                            <input type="checkbox" id="bulk-clear-episode-title"> Clear
                        </label>
                    </div>
                    <div>
                        <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Movie Title</div>
                        <input type="text" id="bulk-movie-title" style="width:100%;" autocomplete="off">
                        <label style="color:#888; font-size:0.75em; display:flex; align-items:center; gap:6px; margin-top:4px;">
                            <input type="checkbox" id="bulk-clear-movie-title"> Clear
                        </label>
                    </div>
                    <div>
                        <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Year</div>
                        <input type="number" id="bulk-year" style="width:100%;" autocomplete="off">
                        <label style="color:#888; font-size:0.75em; display:flex; align-items:center; gap:6px; margin-top:4px;">
                            <input type="checkbox" id="bulk-clear-year"> Clear
                        </label>
                    </div>
                </div>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:10px;">
                    <div>
                        <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Season</div>
                        <input type="number" id="bulk-season" style="width:100%;" autocomplete="off">
                        <label style="color:#888; font-size:0.75em; display:flex; align-items:center; gap:6px; margin-top:4px;">
                            <input type="checkbox" id="bulk-clear-season"> Clear
                        </label>
                    </div>
                    <div>
                        <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Episode</div>
                        <input type="number" id="bulk-episode" style="width:100%;" autocomplete="off">
                        <label style="color:#888; font-size:0.75em; display:flex; align-items:center; gap:6px; margin-top:4px;">
                            <input type="checkbox" id="bulk-clear-episode"> Clear
                        </label>
                    </div>
                    <div>
                        <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Video Source</div>
                        <input type="text" id="bulk-video-source" style="width:100%;" autocomplete="off">
                        <label style="color:#888; font-size:0.75em; display:flex; align-items:center; gap:6px; margin-top:4px;">
                            <input type="checkbox" id="bulk-clear-video-source"> Clear
                        </label>
                    </div>
                    <div>
                        <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Source Format</div>
                        <input type="text" id="bulk-source-format" style="width:100%;" autocomplete="off">
                        <label style="color:#888; font-size:0.75em; display:flex; align-items:center; gap:6px; margin-top:4px;">
                            <input type="checkbox" id="bulk-clear-source-format"> Clear
                        </label>
                    </div>
                </div>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:10px;">
                    <div>
                        <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Main HDR</div>
                        <input type="text" id="bulk-main-hdr" style="width:100%;" autocomplete="off">
                        <label style="color:#888; font-size:0.75em; display:flex; align-items:center; gap:6px; margin-top:4px;">
                            <input type="checkbox" id="bulk-clear-main-hdr"> Clear
                        </label>
                    </div>
                    <div>
                        <div style="color:#888; font-size:0.8em; margin-bottom:4px;">Secondary HDR</div>
                        <input type="text" id="bulk-secondary-hdr" style="width:100%;" autocomplete="off">
                        <label style="color:#888; font-size:0.75em; display:flex; align-items:center; gap:6px; margin-top:4px;">
                            <input type="checkbox" id="bulk-clear-secondary-hdr"> Clear
                        </label>
                    </div>
                </div>
                <div class="modal-footer" style="display:flex; gap:10px; margin-top:15px;">
                    <button class="btn-grey" style="flex:1;" onclick="closeBulkEdit()">Cancel</button>
                    <button class="btn-orange" style="flex:1;" onclick="bulkRescanSelected()">Rescan Selected</button>
                    <button class="btn-blue" style="flex:1;" onclick="applyBulkEdit()">Apply</button>
                </div>
            </div>
        </div>
    </div>

    <div id="toast-container">
        <div id="toast-notif" class="toast">Scan Complete!</div>
    </div>

    <div id="volume-modal" class="modal-bg">
        <div class="report-content" style="width: 500px;">
            <h2 style="margin-top:0; letter-spacing: 2px;">SELECT <span style="color:#3498db">VOLUMES</span></h2>
            <div id="vol-list-container" class="vol-list"></div>
            <label class="rescan-opt">
                <input type="checkbox" id="chk-force-rescan">
                <span>Force Full Rescan (Retry Failed Files)</span>
            </label>
            <div style="display:flex; gap:10px; margin-top:15px;">
                <button class="btn-grey" style="flex:1;" onclick="document.getElementById('volume-modal').style.display='none'">Cancel</button>
                <button class="btn-blue" style="flex:1;" onclick="confirmScan(true, scanMode)">Start Scan</button>
            </div>
        </div>
    </div>

    <div id="folders-modal" class="modal-bg">
        <div class="details-content" style="width: 900px;">
            <div class="details-header">
                <h3 style="margin:0; color:#3498db">SCAN FOLDERS</h3>
                <button class="btn-grey" onclick="closeFoldersModal()">✕</button>
            </div>
            <div class="details-body">
                <p style="color:#888; font-size:0.9em; margin-top:0;">
                    Add specific folders to scan. Muted folders stay in the list but are skipped.
                </p>
                <div class="folder-browser">
                    <div>
                        <div style="color:#888; font-size:0.8em; margin-bottom:6px;">Volume</div>
                        <select id="folders-volume-select" style="width:100%; margin-bottom:10px;" onchange="onFoldersVolumeChange()"></select>
                        <div style="display:flex; gap:6px; align-items:center; margin-bottom:6px;">
                            <button class="btn-grey folder-item-btn" onclick="browseFolderUp()">Up</button>
                            <div id="folders-current-path" class="folder-path" style="flex:1;">/</div>
                        </div>
                        <div id="folders-dir-list" class="folder-list"></div>
                        <div style="display:flex; gap:6px; margin-top:10px;">
                            <button class="btn-blue" style="flex:1;" onclick="addCurrentFolder()">+ Add Selected Folder</button>
                        </div>
                    </div>
                    <div>
                        <div style="color:#888; font-size:0.8em; margin-bottom:6px;">Scan List</div>
                        <div id="folders-scan-list" class="folder-list"></div>
                    </div>
                </div>
                <div class="modal-footer" style="display:flex; gap:10px; margin-top:15px;">
                    <button class="btn-grey" style="flex:1;" onclick="closeFoldersModal()">Cancel</button>
                    <button class="btn-blue" style="flex:1;" onclick="saveScanFolders()">Save</button>
                </div>
            </div>
        </div>
    </div>

    <div id="report-modal" class="modal-bg">
        <div class="report-content">
            <h2 style="margin-top:0; letter-spacing: 2px;">SCAN <span style="color:#3498db">COMPLETE</span></h2>
            <div class="report-grid">
                <div class="report-item"><div class="stat-label">Scanned</div><div class="stat-value" id="rep-scanned">0</div></div>
                <div class="report-item"><div class="stat-label">New Added</div><div class="stat-value" id="rep-new">0</div></div>
                <div class="report-item"><div class="stat-label">Failures</div><div class="stat-value" id="rep-failed" style="color:#e74c3c">0</div></div>
                <div class="report-item"><div class="stat-label">Duration</div><div class="stat-value" id="rep-time">0s</div></div>
            </div>
            <div id="rep-offline-box" style="display:none; background:rgba(231, 76, 60, 0.15); border:1px solid #e74c3c; border-radius:8px; padding:10px; margin-bottom:20px; text-align:left;">
                <div style="color:#e74c3c; font-weight:bold; font-size:0.8em; margin-bottom:5px;">⚠️ OFFLINE VOLUMES (SKIPPED):</div>
                <div id="rep-offline-list" style="font-family:monospace; font-size:0.85em; color:#ffb6c1;"></div>
            </div>
            <div style="display:flex; gap:10px;">
                <button class="btn-green" style="flex:1;" onclick="window.location='/download_log'">Download Log</button>
                <button class="btn-blue" style="flex:1;" onclick="document.getElementById('report-modal').style.display='none'">Close</button>
            </div>
        </div>
    </div>

    <div id="delete-modal" class="modal-bg">
        <div class="warn-content">
            <h3 style="color:#e74c3c">Confirm Deletion</h3>
            <p>You are about to remove <span id="del-count" style="font-weight:bold; color:white;">0</span> entries.</p>
            <div style="display:flex; gap:10px; justify-content:center; margin-top:20px;">
                <button class="btn-grey" onclick="document.getElementById('delete-modal').style.display='none'">Cancel</button>
                <button class="btn-red" onclick="confirmDelete()">Delete</button>
            </div>
        </div>
    </div>

    <div id="clean-db-modal" class="modal-bg">
        <div class="report-content" style="width: 520px;">
            <h2 style="margin-top:0; letter-spacing: 2px;">CLEAN DATABASE</h2>
            <p style="color:#bbb; font-size:0.9em; line-height:1.4;">
                This will delete entries that belong to volumes that are not mounted or are outside your selected scan folders.
            </p>
            <p id="clean-db-preview" style="color:#888; font-size:0.9em; line-height:1.4;">
                Preview: Loading number of entries which will be removed. Please wait...
            </p>
            <p style="color:#e67e22; font-size:0.9em; line-height:1.4;">
                This action cannot be undone.
            </p>
            <div style="display:flex; gap:10px; margin-top:15px;">
                <button class="btn-grey" style="flex:1;" onclick="document.getElementById('clean-db-modal').style.display='none'">Cancel</button>
                <button class="btn-orange" style="flex:1;" onclick="confirmCleanDb()">Continue</button>
            </div>
        </div>
    </div>

    <div id="row-context-menu" class="context-menu">
        <button onclick="contextRescan()">Rescan</button>
        <button onclick="openBulkEdit()">Bulk Edit/Rescan</button>
        <button onclick="contextCopyPath()">Copy Path</button>
        <div class="context-divider"></div>
        <button onclick="selectAllRows()">Select All on Page</button>
        <button onclick="selectAllFilteredRows()">Select All Filtered</button>
        <button onclick="deselectAllRows()">Deselect All</button>
    </div>

    <div class="container">
        <div style="display:flex; justify-content: space-between; align-items: flex-end; margin-bottom: 20px; position: relative;">
            <div style="display:flex; align-items: center; gap: 15px; position: relative; z-index: 100;">
            <h1 style="margin:0; font-weight: 300; letter-spacing: -1px;">Video <span style="font-weight: 800; color:#3498db">Analyzer</span></h1>
                <div id="btn-main-menu" class="settings-toggle" onclick="toggleMainMenu()" style="position: relative; z-index: 101;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
                        <g stroke-width="6.5" stroke-linecap="round">
                            <path d="M72 82.286h28.75" fill="#009100" fill-rule="evenodd" stroke="#fff" />
                            <path d="M100.75 103.714l72.482-.143c.043 39.398-32.284 71.434-72.16 71.434-39.878 0-72.204-32.036-72.204-71.554" fill="none" stroke="#fff" />
                            <path d="M72 125.143h28.75" fill="#009100" fill-rule="evenodd" stroke="#fff" />
                            <path d="M100.75 103.714l-71.908-.143c.026-39.638 32.352-71.674 72.23-71.674 39.876 0 72.203 32.036 72.203 71.554" fill="none" stroke="#fff" />
                            <path d="M100.75 82.286h28.75" fill="#009100" fill-rule="evenodd" stroke="#fff" />
                            <path d="M100.75 125.143h28.75" fill="#009100" fill-rule="evenodd" stroke="#fff" />
                        </g>
                    </svg>
                </div>
            </div>
            <div id="scan-info-box" title="Jump to logs" onclick="scrollToConsole()">IDLE</div>
        </div>

        <div class="main-menu" id="mainMenu">
            <div class="main-menu-left-panel">
                <span class="main-menu-label">MENU</span>
            </div>
            <div class="main-menu-content">
                <div class="main-menu-section">
                    <span class="main-menu-section-label">Export Format:</span>
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="radio" name="export-format" value="csv" id="export-format-csv" checked onchange="updateExportButtonText()" style="width: 16px; height: 16px;">
                        <span>CSV</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="radio" name="export-format" value="json" id="export-format-json" onchange="updateExportButtonText()" style="width: 16px; height: 16px;">
                        <span>JSON</span>
                    </label>
                </div>
                <div style="width: 1px; height: 20px; background: #444; margin: 0 10px;"></div>
                <div class="main-menu-section">
                    <button class="btn-grey" onclick="backupDatabase()" style="padding: 5px 15px; font-size: 0.85em;">Backup DB</button>
                    <input type="file" id="restore-file-input" accept=".zip,.tar,.gz" style="display: none;" onchange="restoreDatabase(this)">
                    <button class="btn-grey" onclick="document.getElementById('restore-file-input').click()" style="padding: 5px 15px; font-size: 0.85em;">Restore DB</button>
                </div>
                <div style="width: 1px; height: 20px; background: #444; margin: 0 10px;"></div>
                <div class="main-menu-section">
                    <span style="font-size: 0.7em; color: #3498db; font-weight: bold; letter-spacing: 1px;">DATABASE:</span>
                    <button id="maintenance-db-btn" class="btn-grey" onclick="runDatabaseMaintenance()" style="padding: 5px 15px; font-size: 0.85em;">Optimize DB</button>
                    <button class="btn-grey" onclick="backfillMetadata()" style="padding: 5px 15px; font-size: 0.85em;">Backfill Metadata</button>
                    <button class="btn-orange" onclick="openCleanDbModal()" style="padding: 5px 15px; font-size: 0.85em;">Clean DB</button>
                </div>
                <div style="width: 1px; height: 20px; background: #444; margin: 0 10px;"></div>
                <div class="main-menu-section">
                    <span style="font-size: 0.7em; color: #3498db; font-weight: bold; letter-spacing: 1px;">SCAN:</span>
                    <button class="btn-grey" onclick="openFoldersModal()" style="padding: 5px 15px; font-size: 0.85em;">Folders</button>
                </div>
                <div style="width: 1px; height: 20px; background: #444; margin: 0 10px;"></div>
                <div class="main-menu-section">
                    <span class="main-menu-section-label">Filter Presets:</span>
                    <input type="text" id="preset-name-input" placeholder="Preset name" style="width: 120px; padding: 4px; font-size: 0.85em;">
                    <button class="btn-grey" onclick="saveFilterPreset()" style="padding: 5px 10px; font-size: 0.85em;">Save</button>
                    <select id="preset-select" style="width: 140px; padding: 4px; font-size: 0.85em;">
                        <option value="">Select preset...</option>
                    </select>
                    <button class="btn-grey" onclick="loadFilterPreset()" style="padding: 5px 10px; font-size: 0.85em;">Load</button>
                    <button class="btn-grey" onclick="deleteFilterPreset()" style="padding: 5px 10px; font-size: 0.85em;">Delete</button>
                </div>
            </div>
        </div>

        <div class="summary-ribbon">
            <div class="stat-card" onclick="clearFilters()">
                <div class="stat-label">Total Files</div>
                <div class="stat-value" id="stat-total">0</div>
            </div>
            <div class="stat-card" style="border-bottom: 3px solid var(--col-mel);" onclick="applyRibbonFilter('format', 'dovi')">
                <div class="stat-label">DV Titles (All)</div>
                <div class="stat-value" id="stat-dovi" style="color:var(--col-mel)">0</div>
            </div>
            <div class="stat-card" style="border-bottom: 3px dashed #ffb6c1;" onclick="applyRibbonFilter('hybrid', '1')">
                <div class="stat-label">Hybrid</div>
                <div class="stat-value" id="stat-hybrid" style="color:#ffb6c1">0</div>
            </div>
            <div class="stat-card" style="border-bottom: 3px dashed var(--col-fel);" onclick="applyRibbonFilter('el', 'FEL')">
                <div class="stat-label">P7 FEL</div>
                <div class="stat-value" id="stat-fel" style="color: var(--col-fel);">0</div>
            </div>
            <div class="stat-card" style="border-bottom: 3px dashed var(--col-mel);" onclick="applyRibbonFilter('el', 'MEL')">
                <div class="stat-label">P7 MEL</div>
                <div class="stat-value" id="stat-mel" style="color: var(--col-mel);">0</div>
            </div>
            <div class="stat-card" style="border-bottom: 3px dashed #e74c3c;" onclick="applyRibbonFilter('dovi_prof', '8.1')">
                <div class="stat-label">P8.1</div>
                <div class="stat-value" id="stat-p81" style="color: #e74c3c;">0</div>
            </div>
            <div class="stat-card" style="border-bottom: 3px dashed #fd79a8;" onclick="applyRibbonFilter('dovi_prof', '8.4')">
                <div class="stat-label">P8.4</div>
                <div class="stat-value" id="stat-p84" style="color: #fd79a8;">0</div>
            </div>
            <div class="stat-card" style="border-bottom: 3px solid var(--col-10p);" onclick="applyRibbonFilter('format', 'hdr10plus')">
                <div class="stat-label">HDR10+</div>
                <div class="stat-value" id="stat-hdr10plus" style="color:var(--col-10p)">0</div>
            </div>
            <div class="stat-card" style="border-bottom: 3px solid var(--col-10);" onclick="applyRibbonFilter('format', 'hdr10')">
                <div class="stat-label">HDR10</div>
                <div class="stat-value" id="stat-hdr10" style="color:var(--col-10)">0</div>
            </div>
            <div class="stat-card" style="border-bottom: 3px solid var(--col-hlg);" onclick="applyRibbonFilter('format', 'hlg')">
                <div class="stat-label">HLG</div>
                <div class="stat-value" id="stat-hlg" style="color:var(--col-hlg)">0</div>
            </div>
            <div class="stat-card" style="border-bottom: 3px solid var(--col-sdr);" onclick="applyRibbonFilter('format', 'sdr_only')">
                <div class="stat-label">SDR</div>
                <div class="stat-value" id="stat-sdr" style="color:var(--col-sdr)">0</div>
            </div>
            <div class="stat-card" style="border-bottom: 3px solid var(--col-fail);" onclick="applyRibbonFilter('status', 'failed')">
                <div class="stat-label">Failed</div>
                <div class="stat-value" id="stat-failed" style="color:var(--col-fail)">0</div>
            </div>
            <div class="stat-card" style="border-bottom: 3px solid #2ecc71;">
                <div class="stat-label">Duration</div>
                <div class="stat-value" id="stat-duration" style="color:#2ecc71">0s</div>
            </div>
        </div>

        <div class="control-stack">
            <div class="action-panel">
                <div id="main-action-wrapper">
                    <div id="scan-group" class="btn-group-scan" style="position: relative;">
                        <button id="btn-scan" class="btn-scan-main" onclick="startScan()">
                            <div id="scan-label-main">Scan | All</div>
                            <div id="scan-label-sub" class="scan-target-sub" style="display:none;"></div>
                        </button>
                        <button class="btn-scan-toggle" onclick="toggleScanMenu(event)">▾</button>
                        <div id="scan-mode-menu" class="scan-dropdown">
                            <button onclick="selectScanMode('all')">All</button>
                            <div class="scan-menu-item">
                                <div class="scan-menu-label" onclick="selectScanMode('tv')">TV ▸</div>
                                <div id="scan-tv-submenu" class="scan-submenu"></div>
                            </div>
                            <div class="scan-menu-item">
                                <div class="scan-menu-label" onclick="selectScanMode('movie')">Movie ▸</div>
                                <div id="scan-movie-submenu" class="scan-submenu"></div>
                            </div>
                        </div>
                    </div>
                    <button id="btn-delete-action" onclick="promptDelete()">DELETE SELECTED</button>
                </div>
                <button id="btn-abort" onclick="abortScan()">Abort Scan</button>
                <button class="btn-green" id="btn-export" onclick="exportData()">Export CSV</button>
                <button class="btn-grey" id="btn-toggle-charts" onclick="toggleCharts()">Charts ⏵</button>
            </div>
            <div class="status-stack">
                <div id="progress-container"><div id="progress-bar"></div><div id="progress-text">0% COMPLETE</div></div>
                <div class="automation-bar">
                    <div id="btn-settings-anim" class="settings-toggle" onclick="toggleConfigMode()">
                      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
                        <g stroke-width="6.5" stroke-linecap="round">
                          <path d="M72 82.286h28.75" fill="#009100" fill-rule="evenodd" stroke="#fff" />
                          <path d="M100.75 103.714l72.482-.143c.043 39.398-32.284 71.434-72.16 71.434-39.878 0-72.204-32.036-72.204-71.554" fill="none" stroke="#fff" />
                          <path d="M72 125.143h28.75" fill="#009100" fill-rule="evenodd" stroke="#fff" />
                          <path d="M100.75 103.714l-71.908-.143c.026-39.638 32.352-71.674 72.23-71.674 39.876 0 72.203 32.036 72.203 71.554" fill="none" stroke="#fff" />
                          <path d="M100.75 82.286h28.75" fill="#009100" fill-rule="evenodd" stroke="#fff" />
                          <path d="M100.75 125.143h28.75" fill="#009100" fill-rule="evenodd" stroke="#fff" />
                        </g>
                      </svg>
                    </div>
                    <div id="group-schedule" class="sched-group">
                        <span style="font-size: 0.7em; color: #3498db; font-weight: bold; letter-spacing: 1px;">SCHEDULE:</span>
                        <select id="sched-mode" style="width: 140px;" onchange="toggleSchedInput()">
                            <option value="manual">Manual Only</option>
                            <option value="daily">Daily at Time</option>
                            <option value="interval">Every X Hours</option>
                            <option value="weekly">Weekly</option>
                            <option value="monthly">Monthly</option>
                        </select>
                        <div id="sched-val-container" style="display: inline-block;">
                            <input type="number" id="sched-val-hours" placeholder="Hours" style="display:none; width:60px;" onkeypress="if(event.key==='Enter') triggerPulse(this)">
                            <input type="time" id="sched-val-time" style="display:none;" onkeypress="if(event.key==='Enter') triggerPulse(this)">
                            <select id="sched-val-week" style="display:none; width:80px;">
                                <option value="mon">Mon</option>
                                <option value="tue">Tue</option>
                                <option value="wed">Wed</option>
                                <option value="thu">Thu</option>
                                <option value="fri">Fri</option>
                                <option value="sat">Sat</option>
                                <option value="sun">Sun</option>
                            </select>
                            <input type="number" id="sched-val-day" placeholder="Day (1-31)" min="1" max="31" style="display:none;" onkeypress="if(event.key==='Enter') triggerPulse(this)">
                        </div>
                        <div style="display:flex; align-items:center; gap:5px;">
                        <span style="font-size: 0.7em; color: #888;">Notification:</span>
                        <select id="notif-style" style="width: 70px;">
                            <option value="modal">Modal</option>
                            <option value="toast">Toast</option>
                        </select>
                        </div>
                        <div style="display:flex; align-items:center; gap:5px;">
                            <input type="checkbox" id="chk-force" class="set-chk" style="width:16px; height:16px;">
                            <span style="font-size: 0.7em; color: #e67e22; font-weight: bold;">Force Rescan</span>
                        </div>
                        <div style="display:flex; align-items:center; gap:5px;">
                            <input type="checkbox" id="chk-debug" class="set-chk" style="width:16px; height:16px;">
                            <span style="font-size: 0.7em; color: #e74c3c; font-weight: bold;">Debug Log</span>
                        </div>
                        <div style="display:flex; align-items:center; gap:5px;">
                            <span style="font-size: 0.7em; color: #888; font-weight: bold; margin-left: 5px;">THREADS:</span>
                            <input type="number" id="scan-threads" value="4" min="1" max="32" style="width: 50px; text-align: center; color: #3498db; font-weight: bold;" onkeypress="if(event.key==='Enter') triggerPulse(this)">
                        </div>
                    </div>
                    <div id="group-filters" class="filter-group hidden">
                        <span style="font-size: 0.7em; color: #e67e22; font-weight: bold; letter-spacing: 1px;">IGNORE:</span>
                        <input type="text" id="skip-words" placeholder="extras, sample..." style="width: 130px;" onkeypress="if(event.key==='Enter') triggerPulse(this)">
                        <span style="font-size: 0.7em; color: #e67e22; font-weight: bold; letter-spacing: 1px; margin-left: 5px;">MIN(MB):</span>
                        <input type="number" id="min-size" placeholder="50" style="width: 50px;" onkeypress="if(event.key==='Enter') triggerPulse(this)">
                        <span style="font-size: 0.7em; color: #e67e22; font-weight: bold; letter-spacing: 1px; margin-left: 5px;">LOGS:</span>
                        <input type="number" id="log-limit" value="200" placeholder="200" style="width: 50px;" onkeypress="if(event.key==='Enter') triggerPulse(this)">
                        <span style="font-size: 0.7em; color: #2ecc71; font-weight: bold; letter-spacing: 1px; margin-left: 5px;">REFRESH(S):</span>
                        <input type="number" id="scan-refresh" value="60" placeholder="60" style="width: 50px; text-align: center; color: #2ecc71;" onkeypress="if(event.key==='Enter') triggerPulse(this)">
                        <span style="font-size: 0.7em; color: #9b59b6; font-weight: bold; letter-spacing: 1px; margin-left: 5px;">BATCH:</span>
                        <input type="number" id="batch-size" value="50" min="10" max="500" style="width: 50px; text-align: center; color: #9b59b6;" onkeypress="if(event.key==='Enter') triggerPulse(this)" title="Database batch size">
                        <span style="font-size: 0.7em; color: #9b59b6; font-weight: bold; letter-spacing: 1px; margin-left: 5px;">RPU THRESH:</span>
                        <input type="number" id="rpu-threshold" value="50000" min="10000" max="200000" style="width: 70px; text-align: center; color: #9b59b6;" onkeypress="if(event.key==='Enter') triggerPulse(this)" title="RPU size threshold for FEL detection (bytes)">
                    </div>
                    <div class="right-anchored">
                        <button id="btn-save" onclick="saveSettings()">Save Settings</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="db-view" class="dashboard">
            <div class="chart-box" style="padding:0; height:300px; overflow:hidden;"> 
                <div id="chart-mode-toggle" class="chart-mode-toggle" onclick="toggleChartMode()">Totals</div>
                <div class="chart-toggle-btn" onclick="toggleFormatView()" title="Switch View">↻</div>
                <div id="view-main-fmt" class="chart-view active">
                    <div class="chart-title-overlay">MAIN FORMATS</div>
                    <canvas id="formatChart"></canvas>
                </div>
                <div id="view-sec-fmt" class="chart-view hidden">
                    <div class="chart-title-overlay">SECONDARY FORMATS</div>
                    <canvas id="secChart"></canvas>
                </div>
            </div>
            <div class="chart-box">
                <div class="chart-title-overlay">RESOLUTION</div>
                <canvas id="resChart"></canvas>
            </div>
            <div class="chart-box">
                <div class="chart-title-overlay">VOLUMES</div>
                <div class="vol-header">
                    <span>Palette:</span>
                    <select id="palette-select" onchange="updatePalette()">
                        <option value="all">Combined (All)</option>
                        <option value="vibrant">Vibrant / Dark</option>
                        <option value="nature">Nature / Teal</option>
                        <option value="soft">Soft / Pastel</option>
                    </select>
                </div>
                <canvas id="volChart"></canvas>
            </div>
        </div>

        <div class="controls-wrapper">
            <div class="search-wrap">
            <input type="text" id="search-bar" placeholder="Search..." oninput="debounceSearch()">
                <div id="search-suggestions" class="search-suggestions"></div>
            </div>
            <button class="btn-grey" id="btn-bulk-edit" onclick="openBulkEdit()" disabled style="display:none;">Bulk Edit/Rescan</button>
            
            <div class="controls-right" style="margin-left: auto;">
                <div class="filter-counter-box">
                    Filtered: <span id="res-filtered" style="color: #3498db; font-size: 1.2em; margin-left:5px; margin-right:5px;">0</span> / <span id="res-total-display" style="margin-left:5px;">0</span>
                </div>
                <button class="btn-grey" onclick="clearFilters()">Clear</button>
            </div>
        </div>

        <div class="table-wrap hide-col-video-source hide-col-source-format hide-col-video-codec hide-col-is-3d hide-col-edition hide-col-year hide-col-media-type hide-col-show-title hide-col-season hide-col-episode hide-col-movie-title hide-col-episode-title">
            <div class="col-toggle-menu" id="colMenu">
                <div class="col-menu-left-panel">
                    <span class="col-menu-label">COLUMNS</span>
                    <button class="col-scroll-btn" onclick="document.getElementById('colMenuScroll').scrollBy({left:-100,behavior:'smooth'})">&lt;</button>
            </div>

                <div class="col-menu-scrollable" id="colMenuScroll">
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-hyb" checked onclick="toggleCol(this)"> Hybrid</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-main" checked onclick="toggleCol(this)"> Format</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-prof" checked onclick="toggleCol(this)"> Profile</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-sec" checked onclick="toggleCol(this)"> Secondary</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-res" checked onclick="toggleCol(this)"> Res</div>
                <div style="width:1px; height:15px; background:#444; margin:0 5px;"></div> 
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-width" checked onclick="toggleCol(this)"> Width</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-height" checked onclick="toggleCol(this)"> Height</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-size" checked onclick="toggleCol(this)"> Size</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-bit" checked onclick="toggleCol(this)"> Bitrate</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-vol" checked onclick="toggleCol(this)"> Volume</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-scan" checked onclick="toggleCol(this)"> Scanned</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-stat" checked onclick="toggleCol(this)"> Status</div>
                <div style="width:1px; height:15px; background:#444; margin:0 5px;"></div> 
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-audio" onclick="toggleCol(this)"> Audio</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-sub" onclick="toggleCol(this)"> Subs</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-el" onclick="toggleCol(this)"> EL Type</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-cont" onclick="toggleCol(this)"> Container</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-cll" onclick="toggleCol(this)"> MaxCLL</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-fall" onclick="toggleCol(this)"> MaxFALL</div>
                <div style="width:1px; height:15px; background:#444; margin:0 5px;"></div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-video-source" onclick="toggleCol(this)"> Source</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-source-format" onclick="toggleCol(this)"> Src Format</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-video-codec" onclick="toggleCol(this)"> Codec</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-is-3d" onclick="toggleCol(this)"> 3D</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-edition" onclick="toggleCol(this)"> Edition</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-year" onclick="toggleCol(this)"> Year</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-media-type" onclick="toggleCol(this)"> Media Type</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-show-title" onclick="toggleCol(this)"> Show Title</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-season" onclick="toggleCol(this)"> Season</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-episode" onclick="toggleCol(this)"> Episode</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-movie-title" onclick="toggleCol(this)"> Movie Title</div>
                <div class="col-toggle-item"><input type="checkbox" class="col-chk-input" data-target="col-episode-title" onclick="toggleCol(this)"> Episode Title</div>
                </div>

                <div class="col-menu-right-panel">
                    <button class="col-scroll-btn" onclick="document.getElementById('colMenuScroll').scrollBy({left:100,behavior:'smooth'})">&gt;</button>
                </div>
            </div>
            <div id="header-scrollbar-panel" class="header-scrollbar-panel">
                <div id="header-scrollbar" class="header-scrollbar"><div id="header-scrollbar-inner" class="header-scrollbar-inner"></div></div>
            </div>
            <div class="table-scroll" id="table-scroll">
            <table>
                <thead>
                    <tr>
                        <th class="col-chk">
                            <input type="checkbox" id="master-chk" onclick="toggleMaster(this)" style="display: block; margin: 0 auto; width: 18px; height: 18px; flex-shrink: 0;">
                        </th>
                        <th class="col-file" onclick="sortBy('file')" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Filename</span>
                                <span id="sort-file" class="sort-icon"></span>
                            </div>
                        </th>
                        <th class="col-hyb td-center" onclick="sortBy('hybrid', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Hybrid</span>
                                <span id="sort-hybrid" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <select id="hybrid-filter-header" class="filter-item" onchange="resetAndLoad()" onmousedown="event.stopPropagation()" onclick="event.stopPropagation()" style="width:100%;">
                                    <option value="">All</option>
                                    <option value="1">Hybrid</option>
                                    <option value="0">Standard</option>
                                </select>
                            </div>
                        </th>
                        <th class="col-main td-center" onclick="sortBy('main', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Main HDR</span>
                                <span id="sort-main" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <div class="multiselect-wrapper">
                                    <div class="multiselect-button" id="format-filter-button" onclick="toggleFormatMultiselect(event)">
                                        <span id="format-filter-text">All</span>
                                        <span class="multiselect-arrow">▼</span>
                                    </div>
                                    <div class="multiselect-dropdown" id="format-filter-dropdown">
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="format-chk-all" checked onchange="toggleAllFormats(this)">
                                            <label for="format-chk-all">All</label>
                                        </div>
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="format-chk-blank" value="__blank__" onchange="updateFormatFilter()">
                                            <label for="format-chk-blank">Blanks</label>
                                        </div>
                                        <div class="multiselect-divider"></div>
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="format-chk-dovi" value="dovi" onchange="updateFormatFilter()">
                                            <label for="format-chk-dovi">Dolby Vision</label>
                                        </div>
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="format-chk-hdr10plus" value="hdr10plus" onchange="updateFormatFilter()">
                                            <label for="format-chk-hdr10plus">HDR10+</label>
                                        </div>
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="format-chk-hdr10" value="hdr10" onchange="updateFormatFilter()">
                                            <label for="format-chk-hdr10">HDR10</label>
                                        </div>
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="format-chk-hlg" value="hlg" onchange="updateFormatFilter()">
                                            <label for="format-chk-hlg">HLG</label>
                                        </div>
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="format-chk-sdr" value="sdr_only" onchange="updateFormatFilter()">
                                            <label for="format-chk-sdr">SDR</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </th>
                        <th class="col-prof td-center" onclick="sortBy('prof', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>DV Prof</span>
                                <span id="sort-prof" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <div class="multiselect-wrapper" id="profile-filter-wrapper">
                                    <div class="multiselect-button">
                                        <span id="profile-filter-text">All</span>
                                        <span class="multiselect-arrow">▼</span>
                                    </div>
                                    <div class="multiselect-dropdown" id="profile-filter-dropdown">
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="profile-filter-chk-all" checked>
                                            <label for="profile-filter-chk-all">All</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </th>
                        <th class="col-el hide-col-el td-center" onclick="sortBy('el', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>EL Type</span>
                                <span id="sort-el" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <div class="multiselect-wrapper" id="el-filter-wrapper">
                                    <div class="multiselect-button">
                                        <span id="el-filter-text">All</span>
                                        <span class="multiselect-arrow">▼</span>
                                    </div>
                                    <div class="multiselect-dropdown" id="el-filter-dropdown">
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="el-filter-chk-all" checked>
                                            <label for="el-filter-chk-all">All</label>
                                        </div>
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="el-filter-chk-FEL" value="FEL">
                                            <label for="el-filter-chk-FEL">FEL</label>
                                        </div>
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="el-filter-chk-MEL" value="MEL">
                                            <label for="el-filter-chk-MEL">MEL</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </th>
                        <th class="col-sec td-center" onclick="sortBy('sec', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Secondary</span>
                                <span id="sort-sec" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <div class="multiselect-wrapper" id="secondary-filter-wrapper">
                                    <div class="multiselect-button">
                                        <span id="secondary-filter-text">All</span>
                                        <span class="multiselect-arrow">▼</span>
                                    </div>
                                    <div class="multiselect-dropdown" id="secondary-filter-dropdown">
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="secondary-filter-chk-all" checked>
                                            <label for="secondary-filter-chk-all">All</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </th>
                        <th class="col-res td-center" onclick="sortBy('res', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Res</span>
                                <span id="sort-res" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <div class="multiselect-wrapper" id="res-filter-wrapper">
                                    <div class="multiselect-button">
                                        <span id="res-filter-text">All</span>
                                        <span class="multiselect-arrow">▼</span>
                                    </div>
                                    <div class="multiselect-dropdown" id="res-filter-dropdown">
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="res-filter-chk-all" checked>
                                            <label for="res-filter-chk-all">All</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </th>
                        <th class="col-width td-center" onclick="sortBy('width', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Width</span>
                                <span id="sort-width" class="sort-icon"></span>
                            </div>
                        </th>
                        <th class="col-height td-center" onclick="sortBy('height', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Height</span>
                                <span id="sort-height" class="sort-icon"></span>
                            </div>
                        </th>
                        <th class="col-size" onclick="sortBy('size', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Size</span>
                                <span id="sort-size" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <input type="text" id="size-filter-header" placeholder="e.g. >30GB, <100MB, =50GB" onkeypress="if(event.key==='Enter') resetAndLoad()">
                            </div>
                        </th>
                        <th class="col-bit" onclick="sortBy('bit', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Bitrate</span>
                                <span id="sort-bit" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <input type="text" id="bit-filter-header" placeholder="e.g. >50Mbps, <20Mbps, =30Mbps" onkeypress="if(event.key==='Enter') resetAndLoad()">
                            </div>
                        </th>
                        <th class="col-vol" onclick="sortBy('vol', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Volume</span>
                                <span id="sort-vol" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <div class="multiselect-wrapper" id="vol-filter-wrapper">
                                    <div class="multiselect-button">
                                        <span id="vol-filter-text">All</span>
                                        <span class="multiselect-arrow">▼</span>
                                    </div>
                                    <div class="multiselect-dropdown" id="vol-filter-dropdown">
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="vol-filter-chk-all" checked>
                                            <label for="vol-filter-chk-all">All</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </th>
                        <th class="col-cont td-center" onclick="sortBy('cont', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Container</span>
                                <span id="sort-cont" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <div class="multiselect-wrapper" id="container-filter-wrapper">
                                    <div class="multiselect-button">
                                        <span id="container-filter-text">All</span>
                                        <span class="multiselect-arrow">▼</span>
                                    </div>
                                    <div class="multiselect-dropdown" id="container-filter-dropdown">
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="container-filter-chk-all" checked>
                                            <label for="container-filter-chk-all">All</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </th>
                        <th class="col-scan" onclick="sortBy('scan', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Scanned</span>
                                <span id="sort-scan" class="sort-icon"></span>
                            </div>
                        </th>
                        <th class="col-stat td-center" onclick="sortBy('stat', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Status</span>
                                <span id="sort-stat" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <select id="status-filter-header" class="filter-item" onchange="resetAndLoad()" onmousedown="event.stopPropagation()" onclick="event.stopPropagation()" style="width:100%;">
                                    <option value="">All</option>
                                    <option value="ok">OK</option>
                                    <option value="failed">Failed</option>
                                </select>
                            </div>
                        </th>
                        
                        <th class="col-audio hide-col-audio">
                            <div class="th-header-row">
                                <span>Audio</span>
                            </div>
                            <div class="th-filter-row">
                                <div class="multiselect-wrapper" id="audio-filter-wrapper">
                                    <div class="multiselect-button">
                                        <span id="audio-filter-text">All</span>
                                        <span class="multiselect-arrow">▼</span>
                                    </div>
                                    <div class="multiselect-dropdown" id="audio-filter-dropdown">
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="audio-filter-chk-all" checked>
                                            <label for="audio-filter-chk-all">All</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </th>
                        <th class="col-sub hide-col-sub td-center">
                            <div class="th-header-row">
                                <span>Subs</span>
                            </div>
                        </th>
                        <th class="col-cll hide-col-cll td-center" onclick="sortBy('cll', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>CLL</span>
                                <span id="sort-cll" class="sort-icon"></span>
                            </div>
                        </th>
                        <th class="col-fall hide-col-fall td-center" onclick="sortBy('fall', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>FALL</span>
                                <span id="sort-fall" class="sort-icon"></span>
                            </div>
                        </th>
                        <th class="col-video-source hide-col-video-source td-center" onclick="sortBy('video_source', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Source</span>
                                <span id="sort-video_source" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <div class="multiselect-wrapper" id="video-source-filter-wrapper">
                                    <div class="multiselect-button" onclick="event.stopPropagation(); toggleMultiselect('video-source-filter');">
                                        <span id="video-source-filter-text">All</span>
                                        <span class="multiselect-arrow">▼</span>
                                    </div>
                                    <div class="multiselect-dropdown" id="video-source-filter-dropdown">
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="video-source-filter-chk-all" checked>
                                            <label for="video-source-filter-chk-all">All</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </th>
                        <th class="col-source-format hide-col-source-format td-center" onclick="sortBy('source_format', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Src Format</span>
                                <span id="sort-source_format" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <div class="multiselect-wrapper" id="source-format-filter-wrapper">
                                    <div class="multiselect-button" onclick="event.stopPropagation(); toggleMultiselect('source-format-filter');">
                                        <span id="source-format-filter-text">All</span>
                                        <span class="multiselect-arrow">▼</span>
                                    </div>
                                    <div class="multiselect-dropdown" id="source-format-filter-dropdown">
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="source-format-filter-chk-all" checked>
                                            <label for="source-format-filter-chk-all">All</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </th>
                        <th class="col-video-codec hide-col-video-codec td-center" onclick="sortBy('video_codec', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Codec</span>
                                <span id="sort-video_codec" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <div class="multiselect-wrapper" id="video-codec-filter-wrapper">
                                    <div class="multiselect-button" onclick="event.stopPropagation(); toggleMultiselect('video-codec-filter');">
                                        <span id="video-codec-filter-text">All</span>
                                        <span class="multiselect-arrow">▼</span>
                                    </div>
                                    <div class="multiselect-dropdown" id="video-codec-filter-dropdown">
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="video-codec-filter-chk-all" checked>
                                            <label for="video-codec-filter-chk-all">All</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </th>
                        <th class="col-is-3d hide-col-is-3d td-center" onclick="sortBy('is_3d', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>3D</span>
                                <span id="sort-is_3d" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <select id="is-3d-filter-header" class="filter-item" onchange="resetAndLoad()" onclick="event.stopPropagation();" style="width:100%;">
                                    <option value="">All</option>
                                    <option value="1">3D</option>
                                    <option value="0">2D</option>
                                </select>
                            </div>
                        </th>
                        <th class="col-edition hide-col-edition" onclick="sortBy('edition', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Edition</span>
                                <span id="sort-edition" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <div class="multiselect-wrapper" id="edition-filter-wrapper">
                                    <div class="multiselect-button" onclick="event.stopPropagation(); toggleMultiselect('edition-filter');">
                                        <span id="edition-filter-text">All</span>
                                        <span class="multiselect-arrow">▼</span>
                                    </div>
                                    <div class="multiselect-dropdown" id="edition-filter-dropdown">
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="edition-filter-chk-all" checked>
                                            <label for="edition-filter-chk-all">All</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </th>
                        <th class="col-year hide-col-year td-center" onclick="sortBy('year', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Year</span>
                                <span id="sort-year" class="sort-icon"></span>
                            </div>
                        </th>
                        <th class="col-media-type hide-col-media-type td-center" onclick="sortBy('media_type', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Type</span>
                                <span id="sort-media_type" class="sort-icon"></span>
                            </div>
                            <div class="th-filter-row">
                                <div class="multiselect-wrapper" id="media-type-filter-wrapper">
                                    <div class="multiselect-button" onclick="event.stopPropagation(); toggleMultiselect('media-type-filter');">
                                        <span id="media-type-filter-text">All</span>
                                        <span class="multiselect-arrow">▼</span>
                                    </div>
                                    <div class="multiselect-dropdown" id="media-type-filter-dropdown">
                                        <div class="multiselect-option" onclick="event.stopPropagation()">
                                            <input type="checkbox" id="media-type-filter-chk-all" checked>
                                            <label for="media-type-filter-chk-all">All</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </th>
                        <th class="col-show-title hide-col-show-title" onclick="sortBy('show_title', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Show</span>
                                <span id="sort-show_title" class="sort-icon"></span>
                            </div>
                        </th>
                        <th class="col-season hide-col-season td-center" onclick="sortBy('season', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Season</span>
                                <span id="sort-season" class="sort-icon"></span>
                            </div>
                        </th>
                        <th class="col-episode hide-col-episode td-center" onclick="sortBy('episode', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Episode</span>
                                <span id="sort-episode" class="sort-icon"></span>
                            </div>
                        </th>
                        <th class="col-movie-title hide-col-movie-title" onclick="sortBy('movie_title', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Movie Title</span>
                                <span id="sort-movie_title" class="sort-icon"></span>
                            </div>
                        </th>
                        <th class="col-episode-title hide-col-episode-title" onclick="sortBy('episode_title', event)" style="cursor: pointer;">
                            <div class="th-header-row">
                                <span>Episode Title</span>
                                <span id="sort-episode_title" class="sort-icon"></span>
                            </div>
                        </th>

                        <th class="col-del">
                            <div id="burger-btn" onclick="toggleColMenu()">
                                <div class="settings-toggle table-mode">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"><g stroke-width="10" stroke-linecap="round"><path d="M72 82.286h28.75" fill="#009100" fill-rule="evenodd" stroke="#fff" /><path d="M100.75 103.714l72.482-.143c.043 39.398-32.284 71.434-72.16 71.434-39.878 0-72.204-32.036-72.204-71.554" fill="none" stroke="#fff" /><path d="M72 125.143h28.75" fill="#009100" fill-rule="evenodd" stroke="#fff" /><path d="M100.75 103.714l-71.908-.143c.026-39.638 32.352-71.674 72.23-71.674 39.876 0 72.203 32.036 72.203 71.554" fill="none" stroke="#fff" /><path d="M100.75 82.286h28.75" fill="#009100" fill-rule="evenodd" stroke="#fff" /><path d="M100.75 125.143h28.75" fill="#009100" fill-rule="evenodd" stroke="#fff" /></g></svg>
                                </div>
                            </div>
                        </th> </tr>
                </thead>
                <tbody id="video-table-body"></tbody>
            </table>
            </div>
        </div>

        <div style="display: flex; justify-content: center; gap: 8px; margin-top: 25px; padding-bottom: 20px; align-items: center;">
            <button class="btn-grey" onclick="jumpPage(1)">First</button>
            <button class="btn-grey" onclick="changePage(-10)">&#171;</button>
            <button class="btn-grey" onclick="changePage(-1)">Prev</button>
            <div style="background: #1a1a1a; padding: 8px 16px; border-radius: 8px; border: 1px solid #333; color: #3498db; font-weight: bold;">
                Page <input type="text" id="page-jump" value="1" onkeypress="if(event.key==='Enter') jumpPage(this.value)" style="width: 45px; height: 26px; text-align: center;"> / <span id="pageTotalDisplay">1</span>
            </div>
            <button class="btn-grey" onclick="changePage(1)">Next</button>
            <button class="btn-grey" onclick="changePage(10)">&#187;</button>
            <button class="btn-grey" onclick="jumpPage(999999)">Last</button>
            
            <select id="per-page-select" onchange="resetAndLoad()" style="width: 70px; height: 38px; margin-left:10px; background:#1a1a1a; color:#ccc;">
                <option value="10">10</option>
                <option value="25">25</option>
                <option value="50">50</option>
                <option value="100" selected>100</option>
                <option value="250">250</option>
                <option value="500">500</option>
            </select>
        </div>

        <div class="console-wrap">
            <div class="console-header">
                <span>SYSTEM ACTIVITY LOG (Auto-Refreshing)</span>
                <div style="display:flex; align-items:center;">
                    <a class="go-top-link" onclick="window.scrollTo(0,0)">▲ Top</a>
                    <span style="color:#2ecc71">● Live</span>
                </div>
            </div>
            <div id="debug-console"></div>
        </div>
    </div>

<script>
    // --- GLOBAL VARIABLES ---
    let currentPage = 1, totalPages = 1, searchTimer, formatChart, volChart, resChart, secChart;
    let lastFilterBlanks = {};
    let configMode = 'schedule';
    let scanStartTime = 0; 
    let lastFilterUpdate = 0; // Track last filter update time (independent of duration timer) 
    let selectedPaths = new Set();
    let masterState = 0; 
    let currentRows = [];
    let sortCol = 'scan', sortOrder = 'desc';
    let sortInitialized = false;
    let savedColumnOrder = null;
    let columnDragInitialized = false;
    let lastStats = null; 
    let lastStatsFiltered = null;
    let lastFilterOptions = {};
    let chartMode = 'total';
    let activeFilters = { search: '', category: '', volume: '', profile: '', el: '', container: '', is_hybrid: '', secondary_hdr: '', status: '', resolution: '', size_op: '', size_val: '', bit_op: '', bit_val: '', audio: '', media_type: '' };
    let isLoading = false;
    let isClearingFilters = false; // Flag to prevent loadData() during clearFilters
    let lastScanStatus = "idle"; 
    let refreshIntervalTimer = null; // Timer for periodic table refresh during file analysis
    let isAnalyzingFiles = false; // Flag to track if we're in file analysis phase (total > 0) 
    let selectedRowIndex = -1;
    let scanFolders = [];
    let folderVolumes = [];
    let folderBrowser = { volume: '', path: '' };
    let scanMode = 'all';
    let scanFolderTarget = null;
    let currentRowData = [];
    let currentRowDataEncoded = [];
    let currentDetailsPath = '';
    let currentDetailsMediaType = '';
    let currentDetailsMeta = {};

    // Color generation function - generates distinct colors using HSL color space
    function generateColors(count, paletteStyle = 'vibrant') {
        const colors = [];
        // HSL parameters for different styles
        const styleParams = {
            vibrant: { sMin: 60, sMax: 100, lMin: 40, lMax: 70 },  // High saturation, medium lightness
            nature:  { sMin: 40, sMax: 80, lMin: 35, lMax: 65 },   // Medium saturation, medium-low lightness
            soft:    { sMin: 20, sMax: 60, lMin: 60, lMax: 85 }    // Low saturation, high lightness
        };
        const params = styleParams[paletteStyle] || styleParams.vibrant;
        
        // Generate colors evenly distributed around the hue circle
        for (let i = 0; i < count; i++) {
            const hue = (i * 360 / count) % 360;  // Evenly distribute around hue circle
            const saturation = params.sMin + (i % 3) * (params.sMax - params.sMin) / 2;  // Vary saturation
            const lightness = params.lMin + (i % 2) * (params.lMax - params.lMin);  // Vary lightness
            // Convert HSL to RGB
            const h = hue / 360;
            const s = saturation / 100;
            const l = lightness / 100;
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h * 6) % 2 - 1));
            const m = l - c / 2;
            let r, g, b;
            if (h < 1/6) { r = c; g = x; b = 0; }
            else if (h < 2/6) { r = x; g = c; b = 0; }
            else if (h < 3/6) { r = 0; g = c; b = x; }
            else if (h < 4/6) { r = 0; g = x; b = c; }
            else if (h < 5/6) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);
            colors.push(`#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`);
        }
        return colors;
    }
    
    // PALETTES - now using predefined colors for up to 30 volumes, then generating dynamically
    const PALETTES = {
        vibrant: ['#00202e', '#003f5c', '#2c4875', '#8a508f', '#bc5090', '#ff6361', '#ff8531', '#ffa600', '#660e60', '#893f71', '#ac6f82', '#cfa093', '#f3d0a4', '#002244', '#004466', '#006688', '#ff3366', '#ff6699', '#ff99cc', '#66ccff', '#3399ff', '#0066cc', '#9900cc', '#cc00ff', '#ff00cc', '#ff0099', '#ff0066', '#ff3300', '#ff6600', '#ff9900'],
        nature:  ['#0a2d2e', '#1c4e4f', '#436e6f', '#6a8e8f', '#879693', '#a49e97', '#deae9f', '#efd7cf', '#f7ebe7', '#1a5c5d', '#2d7a7b', '#4a9a9b', '#6bb3b4', '#8ccdce', '#ade7e8', '#5a8a7a', '#6ba68b', '#7cc29c', '#8ddead', '#9edfbe', '#3d6b5a', '#4d7b6a', '#5d8b7a', '#6d9b8a', '#7dab9a'],
        soft:    ['#c45161', '#e094a0', '#f2b6c0', '#f2dde1', '#cbc7d8', '#8db7d2', '#5e62a9', '#434279', '#d4a5b0', '#e5b8c4', '#f6cbd8', '#e8d5e2', '#d9dfec', '#bad5f0', '#9bcaf4', '#7cbff8', '#b4a5d4', '#9585c0', '#7665ac', '#574598', '#c8b8e0', '#d9c9f0', '#ead9ff', '#f5e9ff', '#fff0ff']
    };
    PALETTES.all = [...PALETTES.vibrant, ...PALETTES.nature, ...PALETTES.soft];

    const RES_COLORS = { '4K': '#f1c40f', '1080p': '#3498db', '720p': '#2ecc71', 'SD': '#95a5a6' };

    function formatDuration(raw) {
        if (!raw) return "00:00:00";
        const sec = parseInt(raw.toString().replace('s', ''));
        if (isNaN(sec)) return "00:00:00";
        const h = Math.floor(sec / 3600);
        const m = Math.floor((sec % 3600) / 60);
        const s = sec % 60;
        return [h, m, s].map(v => v < 10 ? "0" + v : v).join(":");
    }
    
    function formatBytes(bytes, decimals = 2) {
        if (!+bytes) return '0 B';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
    }

    // --- SCROLL TO CONSOLE ---
    function scrollToConsole() {
        const consoleEl = document.querySelector('.console-wrap');
        if(consoleEl) consoleEl.scrollIntoView({behavior: "smooth"});
    }

    // --- FILTER CAROUSEL SCROLLING ---
    function scrollFilters(direction) {
        const container = document.getElementById('filter-scroll-area');
        const amount = 150; // Scroll 150px per click
        container.scrollBy({ left: amount * direction, behavior: 'smooth' });
    }
    
    // --- INTERACTION FUNCTIONS ---
    function toggleConfigMode() {
        const btn = document.getElementById('btn-settings-anim');
        const grpSched = document.getElementById('group-schedule');
        const grpFilt = document.getElementById('group-filters');

        btn.classList.toggle('active');
        if (configMode === 'schedule') {
            configMode = 'filters';
            grpSched.classList.add('hidden');
            grpFilt.classList.remove('hidden');
        } else {
            configMode = 'schedule';
            grpFilt.classList.add('hidden');
            grpSched.classList.remove('hidden');
        }
    }

    async function toggleScanMenu(event) {
        if (event) event.stopPropagation();
        const menu = document.getElementById('scan-mode-menu');
        if (!menu) return;
        menu.classList.toggle('active');
        if (menu.classList.contains('active')) {
            if (!scanFolders || scanFolders.length === 0) {
                await refreshScanFolders();
            }
            renderScanSubmenus();
        }
    }

    function selectScanMode(mode) {
        scanMode = mode || 'all';
        scanFolderTarget = null;
        updateScanButtonLabel();
        const menu = document.getElementById('scan-mode-menu');
        if (menu) menu.classList.remove('active');
    }

    function selectScanFolder(mode, encodedPath) {
        scanMode = mode || 'all';
        try {
            scanFolderTarget = JSON.parse(decodeURIComponent(encodedPath));
        } catch (e) {
            scanFolderTarget = null;
        }
        updateScanButtonLabel();
        const menu = document.getElementById('scan-mode-menu');
        if (menu) menu.classList.remove('active');
    }

    function updateScanButtonLabel() {
        const mainEl = document.getElementById('scan-label-main');
        const subEl = document.getElementById('scan-label-sub');
        if (!mainEl || !subEl) return;
        if (scanMode === 'tv') mainEl.innerText = 'Scan | TV';
        else if (scanMode === 'movie') mainEl.innerText = 'Scan | Movie';
        else mainEl.innerText = 'Scan | All';
        if (scanFolderTarget && scanFolderTarget.volume) {
            const pathText = scanFolderTarget.path ? `/${scanFolderTarget.path}` : '/';
            subEl.innerText = `Target: ${scanFolderTarget.volume}${pathText}`;
            subEl.style.display = '';
        } else {
            subEl.innerText = '';
            subEl.style.display = 'none';
        }
    }

    function renderScanSubmenus() {
        const tvMenu = document.getElementById('scan-tv-submenu');
        const movieMenu = document.getElementById('scan-movie-submenu');
        if (!tvMenu || !movieMenu) return;
        const tvFolders = scanFolders.filter(f => !f.muted && (f.type || 'auto') === 'tv');
        const movieFolders = scanFolders.filter(f => !f.muted && (f.type || 'auto') === 'movie');
        const renderItems = (folders, mode) => {
            if (!scanFolders.length) {
                return `<div class="scan-menu-label" style="cursor:default; color:#777;">No folders configured</div>`;
            }
            if (!folders.length) {
                return `<div class="scan-menu-label" style="cursor:default; color:#777;">No ${mode.toUpperCase()} folders (set type in Scan Folders)</div>`;
            }
            return folders.map(f => {
                const payload = encodeURIComponent(JSON.stringify({ volume: f.volume, path: f.path || '' }));
                const label = `${f.volume}${f.path ? '/' + f.path : '/'}`;
                return `<button onclick="selectScanFolder('${mode}', '${payload}')">${label}</button>`;
            }).join('');
        };
        tvMenu.innerHTML = renderItems(tvFolders, 'tv');
        movieMenu.innerHTML = renderItems(movieFolders, 'movie');
    }

    async function refreshScanFolders() {
        try {
            const res = await fetch('/api/settings');
            const data = await res.json();
            if (data.scan_folders) {
                const parsed = JSON.parse(data.scan_folders);
                scanFolders = Array.isArray(parsed) ? parsed : [];
            }
        } catch (e) {
            console.error('Failed to refresh scan folders', e);
        }
    }

    document.addEventListener('click', (e) => {
        const menu = document.getElementById('scan-mode-menu');
        if (!menu) return;
        if (!e.target.closest('.btn-group-scan')) {
            menu.classList.remove('active');
        }
    });
    
    function toggleSchedInput() {
        const mode = document.getElementById('sched-mode').value;
        const valContainer = document.getElementById('sched-val-container');
        Array.from(valContainer.children).forEach(el => el.style.display = 'none');
        
        if (mode === 'daily') document.getElementById('sched-val-time').style.display = 'block';
        else if (mode === 'interval') document.getElementById('sched-val-hours').style.display = 'block';
        else if (mode === 'weekly') document.getElementById('sched-val-week').style.display = 'block';
        else if (mode === 'monthly') document.getElementById('sched-val-day').style.display = 'block';
    }

    // --- MULTISELECT FORMAT FILTER ---
    let formatMultiselectOpen = false;
    
    function toggleFormatMultiselect(event) {
        event.stopPropagation();
        const dropdown = document.getElementById('format-filter-dropdown');
        const button = document.getElementById('format-filter-button');
        formatMultiselectOpen = !formatMultiselectOpen;
        dropdown.classList.toggle('active', formatMultiselectOpen);
        button.classList.toggle('active', formatMultiselectOpen);
    }
    
    function toggleAllFormats(checkbox) {
        const checkboxes = document.querySelectorAll('#format-filter-dropdown input[type="checkbox"]:not(#format-chk-all)');
        checkboxes.forEach(cb => cb.checked = checkbox.checked);
        updateFormatFilter();
    }
    
    function updateFormatFilter(doReload = true) {
        const allCheckbox = document.getElementById('format-chk-all');
        const checkboxes = Array.from(document.querySelectorAll('#format-filter-dropdown input[type="checkbox"]:not(#format-chk-all)'));
        const selected = checkboxes.filter(cb => cb.checked).map(cb => cb.value);
        
        // Update "All" checkbox state
        if (allCheckbox) {
            allCheckbox.checked = selected.length === 0 || selected.length === checkboxes.length;
        }
        
        // Update button text
        const buttonText = document.getElementById('format-filter-text');
        if (buttonText) {
            if (selected.length === 0 || selected.length === checkboxes.length) {
                buttonText.textContent = 'All';
            } else if (selected.length === 1) {
                const labels = { 'dovi': 'Dolby Vision', 'hdr10plus': 'HDR10+', 'hdr10': 'HDR10', 'hlg': 'HLG', 'sdr_only': 'SDR', '__blank__': 'Blanks' };
                buttonText.textContent = labels[selected[0]] || selected[0];
            } else {
                buttonText.textContent = `Format (${selected.length})`;
            }
        }
        
        // Apply filter only if doReload is true
        if (doReload) {
            resetAndLoad();
        }
    }
    
    function closeFormatMultiselect() {
        formatMultiselectOpen = false;
        document.getElementById('format-filter-dropdown').classList.remove('active');
        document.getElementById('format-filter-button').classList.remove('active');
    }
    
    function getFormatFilterValue() {
        // Check pending value first (set by setFormatFilterValue), then fall back to checkboxes
        if (pendingFormatValue) {
            console.log(`[DEBUG] getFormatFilterValue(): Using pendingFormatValue = "${pendingFormatValue}"`);
            return pendingFormatValue;
        }
        const checkboxes = Array.from(document.querySelectorAll('#format-filter-dropdown input[type="checkbox"]:not(#format-chk-all)'));
        const selected = checkboxes.filter(cb => cb.checked).map(cb => cb.value);
        const result = selected.length === 0 || selected.length === checkboxes.length ? '' : selected.join(',');
        console.log(`[DEBUG] getFormatFilterValue(): Found ${checkboxes.length} checkboxes, ${selected.length} checked, pendingFormatValue = "${pendingFormatValue}", result = "${result}"`);
        return result;
    }
    
    function setFormatFilterValue(value) {
        // Store pending value to persist through dropdown updates
        if (value && value !== '') {
            pendingFormatValue = value;
        } else {
            pendingFormatValue = null;
        }
        
        // Clear all first
        document.querySelectorAll('#format-filter-dropdown input[type="checkbox"]').forEach(cb => cb.checked = false);
        const allCheckbox = document.getElementById('format-chk-all');
        if (allCheckbox) allCheckbox.checked = true;
        
        if (!value || value === '') {
            updateFormatFilter(false);
            return;
        }
        
        const values = value.split(',').map(v => v.trim());
        let foundAny = false;
        values.forEach(val => {
            // Map 'sdr_only' to 'sdr' for checkbox ID
            const checkboxId = val === 'sdr_only' ? 'format-chk-sdr' : (val === '__blank__' ? 'format-chk-blank' : `format-chk-${val}`);
            const checkbox = document.getElementById(checkboxId);
            if (checkbox) {
                checkbox.checked = true;
                foundAny = true;
                if (allCheckbox) allCheckbox.checked = false;
            }
        });
        
        // Update UI without reloading
        updateFormatFilter(false);
        
        // If we found checkboxes, trigger reload after a small delay to ensure state is set
        // Don't clear pendingFormatValue here - it will be used by getFormatFilterValue() and cleared after loadData() reads it
        if (foundAny) {
            setTimeout(() => {
                // Ensure checkboxes are still set before reloading
                const checkboxes = Array.from(document.querySelectorAll('#format-filter-dropdown input[type="checkbox"]:not(#format-chk-all)'));
                const checked = checkboxes.filter(cb => cb.checked);
                if (checked.length === 0) {
                    // Re-set checkboxes if they were cleared
                    values.forEach(val => {
                        const checkboxId = val === 'sdr_only' ? 'format-chk-sdr' : `format-chk-${val}`;
                        const checkbox = document.getElementById(checkboxId);
                        if (checkbox) checkbox.checked = true;
                    });
                }
                resetAndLoad();
                // Don't clear pendingFormatValue here - let loadData() clear it after reading
            }, 50);
        }
    }
    
    // Store pending format filter value to persist through dropdown updates
    let pendingFormatValue = null;
    
    function updateFormatMultiselect(categories) {
        if (!categories) return;
        // Check for pending value first, then fall back to current checkbox state
        // Don't clear pendingFormatValue here - let getFormatFilterValue() handle it
        const currentValue = getFormatFilterValue();
        const currentValues = currentValue ? currentValue.split(',').map(v => v.trim()) : [];
        
        const formatMap = {
            'dovi': 'Dolby Vision',
            'hdr10plus': 'HDR10+',
            'hdr10': 'HDR10',
            'hlg': 'HLG',
            'sdr_only': 'SDR'
        };
        
        // Update labels with counts
        Object.keys(formatMap).forEach(key => {
            const checkbox = document.getElementById(`format-chk-${key}`);
            const label = document.querySelector(`label[for="format-chk-${key}"]`);
            if (checkbox && label) {
                const count = categories[key] !== undefined ? categories[key] : 0;
                label.textContent = `${formatMap[key]} (${count})`;
                
                // Preserve checked state if it was selected
                if (currentValues.includes(key)) {
                    checkbox.checked = true;
                }
            }
        });

        const blankCheckbox = document.getElementById('format-chk-blank');
        const blankLabel = document.querySelector('label[for="format-chk-blank"]');
        if (blankCheckbox && blankLabel) {
            const blankCount = (lastFilterBlanks && lastFilterBlanks.category !== undefined) ? lastFilterBlanks.category : 0;
            blankLabel.textContent = `Blanks (${blankCount})`;
            if (currentValues.includes('__blank__')) {
                blankCheckbox.checked = true;
            }
        }
        
        // Update "All" checkbox state
        const allCheckbox = document.getElementById('format-chk-all');
        const checkboxes = Array.from(document.querySelectorAll('#format-filter-dropdown input[type="checkbox"]:not(#format-chk-all)'));
        const selected = checkboxes.filter(cb => cb.checked);
        if (allCheckbox) {
            allCheckbox.checked = selected.length === 0 || selected.length === checkboxes.length;
        }
        
        // Update button text without reloading
        updateFormatFilter(false);
    }
    
    // Close multiselect when clicking outside
    document.addEventListener('click', (e) => {
        if (formatMultiselectOpen && !e.target.closest('.multiselect-wrapper')) {
            closeFormatMultiselect();
        }
    });
    
    // --- GENERIC MULTISELECT SYSTEM ---
    const multiselectState = {};
    
    function initMultiselect(filterId, options, labelMap = {}) {
        const wrapper = document.querySelector(`#${filterId}-wrapper`);
        if (!wrapper) return;
        
        const button = wrapper.querySelector('.multiselect-button');
        const dropdown = wrapper.querySelector('.multiselect-dropdown');
        const buttonText = button.querySelector('span:first-child');
        
        multiselectState[filterId] = { open: false, button, dropdown, buttonText, options, labelMap };
        
        button.onclick = (e) => {
            e.stopPropagation();
            toggleMultiselect(filterId);
        };
        
        // Setup "All" checkbox
        const allCheckbox = dropdown.querySelector(`#${filterId}-chk-all`);
        if (allCheckbox) {
            allCheckbox.onchange = () => {
                const checkboxes = dropdown.querySelectorAll(`input[type="checkbox"]:not(#${filterId}-chk-all)`);
                checkboxes.forEach(cb => cb.checked = allCheckbox.checked);
                updateMultiselectFilter(filterId);
            };
        }
        
        // Setup individual checkboxes
        dropdown.querySelectorAll(`input[type="checkbox"]:not(#${filterId}-chk-all)`).forEach(cb => {
            cb.onchange = () => updateMultiselectFilter(filterId);
        });
    }
    
    function toggleMultiselect(filterId) {
        const state = multiselectState[filterId];
        if (!state) return;
        
        state.open = !state.open;
        state.dropdown.classList.toggle('active', state.open);
        state.button.classList.toggle('active', state.open);
    }
    
    function closeMultiselect(filterId) {
        const state = multiselectState[filterId];
        if (!state) return;
        
        state.open = false;
        state.dropdown.classList.remove('active');
        state.button.classList.remove('active');
    }
    
    function getMultiselectValue(filterId) {
        const state = multiselectState[filterId];
        if (!state) {
            console.log(`[DEBUG] getMultiselectValue(${filterId}): No state found`);
            return '';
        }
        
        // Check pending value first (set by setMultiselectValue), then fall back to checkboxes
        if (state.pendingValue) {
            console.log(`[DEBUG] getMultiselectValue(${filterId}): Using pendingValue = "${state.pendingValue}"`);
            return state.pendingValue;
        }
        
        const checkboxes = Array.from(state.dropdown.querySelectorAll(`input[type="checkbox"]:not(#${filterId}-chk-all)`));
        const selected = checkboxes.filter(cb => cb.checked).map(cb => cb.value);
        const result = selected.length === 0 || selected.length === checkboxes.length ? '' : selected.join(',');
        console.log(`[DEBUG] getMultiselectValue(${filterId}): Found ${checkboxes.length} checkboxes, ${selected.length} checked, result = "${result}"`);
        return result;
    }

    function getMultiselectValueAndClearPending(filterId) {
        const value = getMultiselectValue(filterId);
        const state = multiselectState[filterId];
        if (state && state.pendingValue && value === state.pendingValue) {
            state.pendingValue = null;
        }
        return value;
    }
    
    function setMultiselectValue(filterId, value, skipReload = false) {
        const state = multiselectState[filterId];
        if (!state) return;
        
        // Store the value in state so it persists through dropdown rebuilds
        if (value && value !== '') {
            state.pendingValue = value;
        } else {
            state.pendingValue = null;
        }
        
        // Clear all first
        state.dropdown.querySelectorAll(`input[type="checkbox"]`).forEach(cb => cb.checked = false);
        const allCheckbox = state.dropdown.querySelector(`#${filterId}-chk-all`);
        
        if (!value || value === '') {
            // If no value, set "All" to checked
            if (allCheckbox) allCheckbox.checked = true;
            if (!skipReload) {
                updateMultiselectFilter(filterId);
            } else {
                // Just update button text without reloading
                state.buttonText.textContent = 'All';
            }
            return;
        }
        
        // Set specific values - do NOT check "All" checkbox
        const values = value.split(',').map(v => v.trim());
        let foundAny = false;
        values.forEach(val => {
            // Try to find checkbox with exact value match (escape special characters in val)
            const escapedVal = val.replace(/"/g, '&quot;');
            let checkbox = state.dropdown.querySelector(`input[value="${escapedVal}"]`);
            
            // If not found, try without escaping (in case the value in HTML is not escaped)
            if (!checkbox) {
                checkbox = state.dropdown.querySelector(`input[value="${val}"]`);
            }
            
            // If still not found, try to find by ID
            if (!checkbox) {
                checkbox = state.dropdown.querySelector(`#${filterId}-chk-${val.replace(/\./g, '\\.')}`);
            }
            
            // If not found, create it (for cases where dropdown hasn't been populated yet)
            if (!checkbox) {
                // Create a temporary checkbox option for this value
                const optionDiv = document.createElement('div');
                optionDiv.className = 'multiselect-option';
                optionDiv.onclick = (e) => e.stopPropagation();
                const safeId = val.replace(/[^a-zA-Z0-9]/g, '_');
                optionDiv.innerHTML = `<input type="checkbox" id="${filterId}-chk-${safeId}" value="${escapedVal}" checked>
                    <label for="${filterId}-chk-${safeId}">${val}</label>`;
                state.dropdown.appendChild(optionDiv);
                checkbox = optionDiv.querySelector(`input[value="${escapedVal}"]`);
                
                // Re-initialize event handler for this checkbox
                if (checkbox) {
                    checkbox.onchange = () => updateMultiselectFilter(filterId);
                }
            }
            
            if (checkbox) {
                checkbox.checked = true;
                foundAny = true;
            }
        });
        
        // Only check "All" if no specific values were found (shouldn't happen, but safety check)
        if (!foundAny && allCheckbox) {
            allCheckbox.checked = true;
        }
        
        // Don't clear pendingValue if skipReload is true - let loadData() use it
        // Only clear pendingValue when we're not skipping reload (normal user interaction)
        if (!skipReload) {
            // Clear pendingValue now that checkboxes are successfully set
            if (foundAny && state.pendingValue && state.pendingValue === value) {
                state.pendingValue = null;
            }
            updateMultiselectFilter(filterId);
        } else {
            // Keep pendingValue set so loadData() can read it
            // Just update button text without reloading
            const selected = values;
            if (selected.length === 1) {
                state.buttonText.textContent = selected[0] === '__blank__' ? 'Blanks' : (state.labelMap[selected[0]] || selected[0]);
            } else {
                const filterName = filterId.replace('-filter', '').replace(/-/g, ' ');
                state.buttonText.textContent = `${filterName} (${selected.length})`;
            }
        }
    }
    
    function updateMultiselectOptions(filterId, options, labelMap = {}, blankCount = null) {
        if (!options) return;
        const dropdown = document.getElementById(`${filterId}-dropdown`);
        if (!dropdown) return;
        
        if (!multiselectState[filterId]) {
            initMultiselect(filterId, options, labelMap);
        }

        // Check for pending value first (set by setMultiselectValue), then fall back to current value
        const state = multiselectState[filterId];
        let currentValue = '';
        if (state && state.pendingValue) {
            currentValue = state.pendingValue;
            // DON'T clear pending value here - let loadData() use it and clear it
            // pendingValue will be cleared by setMultiselectValue after checkboxes are set
            // or by loadData() after reading it
        } else {
            currentValue = getMultiselectValue(filterId);
        }
        const currentValues = currentValue ? currentValue.split(',').map(v => v.trim()) : [];
        
        let items = Array.isArray(options) ? options : Object.keys(options);
        items = items.filter(item => item !== '__blank__');
        let html = `<div class="multiselect-option" onclick="event.stopPropagation()">
            <input type="checkbox" id="${filterId}-chk-all" checked>
            <label for="${filterId}-chk-all">All</label>
        </div>`;

        const blanksLabel = (blankCount === null || blankCount === undefined) ? 'Blanks' : `Blanks (${blankCount})`;
        html += `<div class="multiselect-option" onclick="event.stopPropagation()">
            <input type="checkbox" id="${filterId}-chk-blank" value="__blank__">
            <label for="${filterId}-chk-blank">${blanksLabel}</label>
        </div>
        <div class="multiselect-divider"></div>`;
        
        items.forEach(key => {
            const val = key.toString();
            let display = labelMap[val] || val.toUpperCase();
            if(val === 'sdr_only') display = 'SDR';
            if(val === 'hdr10plus') display = 'HDR10+';
            if(val === 'none') display = 'None';
            
            const count = !Array.isArray(options) && options[val] !== undefined ? options[val] : 0;
            // Always include items that are currently selected, even if count is 0
            if (!Array.isArray(options) && count === 0 && !currentValues.includes(val)) return;
            
            display += ` (${count})`;
            const checked = currentValues.includes(val) ? 'checked' : '';
            html += `<div class="multiselect-option" onclick="event.stopPropagation()">
                <input type="checkbox" id="${filterId}-chk-${val}" value="${val}" ${checked}>
                <label for="${filterId}-chk-${val}">${display}</label>
            </div>`;
        });
        
        dropdown.innerHTML = html;
        
        // Re-initialize event handlers
        const allCheckbox = dropdown.querySelector(`#${filterId}-chk-all`);
        if (allCheckbox) {
            allCheckbox.onchange = () => {
                const checkboxes = dropdown.querySelectorAll(`input[type="checkbox"]:not(#${filterId}-chk-all)`);
                checkboxes.forEach(cb => cb.checked = allCheckbox.checked);
                updateMultiselectFilter(filterId);
            };
        }
        
        dropdown.querySelectorAll(`input[type="checkbox"]:not(#${filterId}-chk-all)`).forEach(cb => {
            cb.onchange = () => updateMultiselectFilter(filterId);
        });
        
        // If there was a pending value, ensure it's applied (checkboxes should already be checked from HTML, but verify)
        if (currentValues.length > 0) {
            currentValues.forEach(val => {
                const escapedVal = val.replace(/"/g, '&quot;');
                let checkbox = dropdown.querySelector(`input[value="${escapedVal}"]`);
                if (!checkbox) {
                    checkbox = dropdown.querySelector(`input[value="${val}"]`);
                }
                if (checkbox) {
                    checkbox.checked = true;
                    if (allCheckbox) allCheckbox.checked = false;
                }
            });
        }
        
        // Update button text
        updateMultiselectFilter(filterId);
    }
    
    function updateMultiselectFilter(filterId) {
        const state = multiselectState[filterId];
        if (!state) return;
        
        const allCheckbox = state.dropdown.querySelector(`#${filterId}-chk-all`);
        const checkboxes = Array.from(state.dropdown.querySelectorAll(`input[type="checkbox"]:not(#${filterId}-chk-all)`));
        const selected = checkboxes.filter(cb => cb.checked).map(cb => cb.value);
        
        // Update "All" checkbox state
        if (allCheckbox) {
            allCheckbox.checked = selected.length === 0 || selected.length === checkboxes.length;
        }
        
        // Update button text
        if (selected.length === 0 || selected.length === checkboxes.length) {
            state.buttonText.textContent = 'All';
        } else if (selected.length === 1) {
            const label = selected[0] === '__blank__' ? 'Blanks' : (state.labelMap[selected[0]] || selected[0]);
            state.buttonText.textContent = label;
        } else {
            const filterName = filterId.replace('-filter', '').replace(/-/g, ' ');
            state.buttonText.textContent = `${filterName} (${selected.length})`;
        }
        
        // Apply filter but don't close dropdown
        resetAndLoad();
    }
    
    // Close all multiselects when clicking outside
    document.addEventListener('click', (e) => {
        Object.keys(multiselectState).forEach(filterId => {
            const state = multiselectState[filterId];
            if (state.open && !e.target.closest(`#${filterId}-wrapper`)) {
                closeMultiselect(filterId);
            }
        });
    });

    // --- FILTER LOGIC ---
    function applyRibbonFilter(type, value) {
        console.log(`[DEBUG] applyRibbonFilter(${type}, ${value}) - FIRST CLICK`);
        
        // UNIFIED APPROACH: Set pending values FIRST (synchronously) for ALL filter types
        if (type === 'format') {
            console.log(`[DEBUG] Format filter: Setting pendingFormatValue = "${value}" BEFORE clearFilters`);
            pendingFormatValue = value;
        }
        else if (type === 'el') {
            const profileState = multiselectState['profile-filter'];
            const elState = multiselectState['el-filter'];
            if (profileState) {
                profileState.pendingValue = '7';
                console.log(`[DEBUG] EL filter: Set profileState.pendingValue = "7" BEFORE clearFilters`);
            }
            if (elState) {
                elState.pendingValue = value;
                console.log(`[DEBUG] EL filter: Set elState.pendingValue = "${value}" BEFORE clearFilters`);
            }
        }
        else if (type === 'dovi_prof') {
            const state = multiselectState['profile-filter'];
            if (state) {
                state.pendingValue = value;
                console.log(`[DEBUG] DOVI profile: Set state.pendingValue = "${value}" BEFORE clearFilters`);
            }
        }
        
        // NOW clear ALL filters (pending values are already set above)
        console.log(`[DEBUG] Clearing all filters first...`);
        clearFilters(false);
        
        // Re-set pending values AFTER clearFilters to ensure they persist through setTimeout
        if (type === 'format') {
            pendingFormatValue = value;
        }
        else if (type === 'el') {
            const profileState = multiselectState['profile-filter'];
            const elState = multiselectState['el-filter'];
            if (profileState) profileState.pendingValue = '7';
            if (elState) elState.pendingValue = value;
        }
        else if (type === 'dovi_prof') {
            const state = multiselectState['profile-filter'];
            if (state) state.pendingValue = value;
        }
        
        // Set status to 'ok' for format, EL, and DOVI profile filters
        if (type === 'format' || type === 'el' || type === 'dovi_prof') {
            const statEl = document.getElementById('status-filter-header');
            if (statEl) statEl.value = 'ok';
        }
        
        // Set the actual filter values AFTER clearFilters completes (unified setTimeout for ALL types)
        setTimeout(() => {
            if (type === 'format') {
                console.log(`[DEBUG] Format filter: Setting checkboxes after clearFilters`);
                setFormatFilterValue(value);
                console.log(`[DEBUG] Format filter: Calling resetAndLoad()`);
                resetAndLoad();
            }
            else if (type === 'status') {
                console.log(`[DEBUG] Status filter: Setting value after clearFilters`);
                const el = document.getElementById('status-filter-header');
                if (el) el.value = value;
                console.log(`[DEBUG] Status filter: Calling resetAndLoad()`);
                resetAndLoad();
            }
            else if (type === 'hybrid') {
                console.log(`[DEBUG] Hybrid filter: Setting value after clearFilters`);
                const el = document.getElementById('hybrid-filter-header');
                if (el) el.value = value;
                console.log(`[DEBUG] Hybrid filter: Calling resetAndLoad()`);
                resetAndLoad();
            }
            else if (type === 'el') {
                console.log(`[DEBUG] EL filter: Setting checkboxes after clearFilters`);
                setMultiselectValue('profile-filter', '7', true);
                setMultiselectValue('el-filter', value, true);
                console.log(`[DEBUG] EL filter: Calling resetAndLoad()`);
                resetAndLoad();
            }
            else if (type === 'dovi_prof') {
                console.log(`[DEBUG] DOVI profile: Setting checkboxes after clearFilters`);
                setMultiselectValue('profile-filter', value, true);
                console.log(`[DEBUG] DOVI profile: Calling resetAndLoad()`);
                resetAndLoad();
            }
        }, 100);
    }

    function clearFilters(doReload = true) {
        console.log(`[DEBUG] clearFilters(doReload=${doReload})`);
        
        // Set flag to prevent loadData() from running during clearing
        isClearingFilters = true;
        
        // Clear all pending values FIRST before clearing filters
        pendingFormatValue = null;
        const profileState = multiselectState['profile-filter'];
        if (profileState) profileState.pendingValue = null;
        const elState = multiselectState['el-filter'];
        if (elState) elState.pendingValue = null;
        const secondaryState = multiselectState['secondary-filter'];
        if (secondaryState) secondaryState.pendingValue = null;
        const volState = multiselectState['vol-filter'];
        if (volState) volState.pendingValue = null;
        const containerState = multiselectState['container-filter'];
        if (containerState) containerState.pendingValue = null;
        const resState = multiselectState['res-filter'];
        if (resState) resState.pendingValue = null;
        const audioState = multiselectState['audio-filter'];
        if (audioState) audioState.pendingValue = null;
        const videoSourceState = multiselectState['video-source-filter'];
        if (videoSourceState) videoSourceState.pendingValue = null;
        const sourceFormatState = multiselectState['source-format-filter'];
        if (sourceFormatState) sourceFormatState.pendingValue = null;
        const videoCodecState = multiselectState['video-codec-filter'];
        if (videoCodecState) videoCodecState.pendingValue = null;
        const editionState = multiselectState['edition-filter'];
        if (editionState) editionState.pendingValue = null;
        const mediaTypeState = multiselectState['media-type-filter'];
        if (mediaTypeState) mediaTypeState.pendingValue = null;
        
        const searchBar = document.getElementById('search-bar');
        if (searchBar) searchBar.value = '';
        
        // Clear format multiselect
        setFormatFilterValue('');
        
        // Clear all multiselect filters
        setMultiselectValue('vol-filter', '', true);
        setMultiselectValue('profile-filter', '', true);
        setMultiselectValue('el-filter', '', true);
        setMultiselectValue('container-filter', '', true);
        setMultiselectValue('secondary-filter', '', true);
        setMultiselectValue('res-filter', '', true);
        setMultiselectValue('audio-filter', '', true);
        setMultiselectValue('video-source-filter', '', true);
        setMultiselectValue('source-format-filter', '', true);
        setMultiselectValue('video-codec-filter', '', true);
        setMultiselectValue('edition-filter', '', true);
        setMultiselectValue('media-type-filter', '', true);
        
        // Clear single-select filters
        const headerFilters = ['hybrid-filter-header', 'status-filter-header', 'size-filter-header', 'bit-filter-header'];
        headerFilters.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                if (el.tagName === 'SELECT' || el.tagName === 'INPUT') {
                    el.value = '';
                }
            }
        });
        
        // Force a synchronous DOM update by reading a property
        // This ensures all DOM changes are applied before we continue
        void document.body.offsetHeight;
        
        // Clear the flag synchronously at the end (not in setTimeout)
        // The flag prevents loadData() during clearing, and we clear it immediately after all clearing operations
        isClearingFilters = false;
        
        if(doReload) {
            // Use setTimeout to ensure all DOM updates are complete before reloading
            setTimeout(() => {
                console.log(`[DEBUG] clearFilters: Calling resetAndLoad()`);
                resetAndLoad();
            }, 50);
        }
    }
    
    function parseFilterValue(val) {
        if (!val) return { op: '', value: '' };
        val = val.trim();
        // Match operators: >=, <=, ==, >, <, =
        const match = val.match(/^(>=|<=|==|>|<|=)(.+)$/);
        if (match) {
            let op = match[1];
            if (op === '==') op = '=';
            return { op: op, value: match[2].trim() };
        }
        return { op: '=', value: val };
    }
    
    function setFilter(type, val) {
         if (type === 'format') {
             setFormatFilterValue(val);
             resetAndLoad();
             return;
         }
         if (type === 'resolution') {
             // Resolution is a multiselect filter
             setMultiselectValue('res-filter', val);
             resetAndLoad();
             return;
         }
         if (type === 'el') {
             // EL is a multiselect filter
             setMultiselectValue('el-filter', val);
             resetAndLoad();
             return;
         }
         let id = '';
         if (type === 'status') id = 'status-filter-header';
         else if (type === 'hybrid') id = 'hybrid-filter-header';
         else if (type === 'dovi_prof') id = 'profile-filter-header';

         const el = document.getElementById(id);
         if (el) { el.value = val; resetAndLoad(); }
    }
    
    function filterBadge(cat, prof, elType, sec) {
        console.log(`[DEBUG] filterBadge(${cat}, ${prof}, ${elType}, ${sec})`);
        
        // Set pending values BEFORE clearFilters (so they're available when loadData runs)
        // Only set format filter if cat is a valid format (not 'sec' or null)
        if (cat && cat !== 'sec') {
            console.log(`[DEBUG] Badge: Setting pendingFormatValue = "${cat}" BEFORE clearFilters`);
            pendingFormatValue = cat;
        }
        if (prof) {
            const state = multiselectState['profile-filter'];
            if (state) {
                state.pendingValue = prof;
                console.log(`[DEBUG] Badge: Set profileState.pendingValue = "${prof}" BEFORE clearFilters`);
            }
        }
        if (elType) {
            const state = multiselectState['el-filter'];
            if (state) {
                state.pendingValue = elType;
                console.log(`[DEBUG] Badge: Set elState.pendingValue = "${elType}" BEFORE clearFilters`);
            }
        }
        if (sec) {
            const state = multiselectState['secondary-filter'];
            if (state) {
                state.pendingValue = sec;
                console.log(`[DEBUG] Badge: Set secondaryState.pendingValue = "${sec}" BEFORE clearFilters`);
            }
        }
        
        // Set status to 'ok' if we're filtering by profile or EL type
        if (prof || elType) {
            const statEl = document.getElementById('status-filter-header');
            if (statEl) statEl.value = 'ok';
        }
        
        // Now clear all filters (pending values are already set above)
        console.log(`[DEBUG] Badge: Clearing all filters...`);
        clearFilters(false);
        
        // Re-set pending values after clearFilters to ensure they persist through setTimeout
        // Only set format filter if cat is a valid format (not 'sec' or null)
        if (cat && cat !== 'sec') {
            pendingFormatValue = cat;
        }
        if (prof) {
            const state = multiselectState['profile-filter'];
            if (state) state.pendingValue = prof;
        }
        if (elType) {
            const state = multiselectState['el-filter'];
            if (state) state.pendingValue = elType;
        }
        if (sec) {
            const state = multiselectState['secondary-filter'];
            if (state) state.pendingValue = sec;
        }
        
        // Set the actual filter values with delays to ensure DOM is ready
        setTimeout(() => {
            // Only set format filter if cat is a valid format (not 'sec' or null)
            if (cat && cat !== 'sec') {
                console.log(`[DEBUG] Badge: Setting format filter to "${cat}"`);
                setFormatFilterValue(cat);
            }
            if (prof) {
                console.log(`[DEBUG] Badge: Setting profile filter to "${prof}"`);
                setMultiselectValue('profile-filter', prof, true);
            }
            if (elType) {
                console.log(`[DEBUG] Badge: Setting EL filter to "${elType}"`);
                setMultiselectValue('el-filter', elType, true);
            }
            if (sec) {
                console.log(`[DEBUG] Badge: Setting secondary filter to "${sec}"`);
                setMultiselectValue('secondary-filter', sec, true);
            }
            console.log(`[DEBUG] Badge: Calling resetAndLoad()`);
        resetAndLoad();
        }, 100);
    }
    
    function sortBy(col, event) {
        if (columnResizeActive) {
            return;
        }
        // Prevent event bubbling if called from filter row elements
        if (event) {
            event.stopPropagation();
        }
        if (sortCol === col) { sortOrder = (sortOrder === 'asc') ? 'desc' : 'asc'; } 
        else { sortCol = col; sortOrder = 'desc'; }
        sortInitialized = true;
        document.querySelectorAll('.sort-icon').forEach(e => e.innerText = '');
        const arrow = sortOrder === 'asc' ? '▲' : '▼';
        const icon = document.getElementById('sort-' + col);
        if(icon) icon.innerText = arrow;
        loadData();
    }
    
    function updatePalette() { if(lastStats) updateCharts(lastStats, lastStatsFiltered, lastFilterOptions); }
    
    function animateSuccess(btnId, origText, tempText) {
        const btn = document.getElementById(btnId);
        btn.innerText = tempText || "Saved!";
        btn.classList.add('action-success');
        setTimeout(() => {
            btn.classList.remove('action-success');
            btn.innerText = origText;
        }, 1500);
    }

    function animateFailure(btnId, origText) {
        const btn = document.getElementById(btnId);
        btn.innerText = "Error!";
        btn.classList.add('action-fail');
        setTimeout(() => {
            btn.classList.remove('action-fail');
            btn.innerText = origText;
        }, 1500);
    }

    // --- COLUMN TOGGLE LOGIC ---
    function updateColMenuPosition() {
        const menu = document.getElementById('colMenu');
        const rightPanel = menu?.querySelector('.col-menu-right-panel');
        const scrollableArea = menu?.querySelector('.col-menu-scrollable');
        const leftPanel = menu?.querySelector('.col-menu-left-panel');
        if (menu && rightPanel && scrollableArea && leftPanel) {
            // Position right panel at the right edge of the menu (which ends 40px before the hamburger)
            rightPanel.style.right = '0px';
            const rightPanelWidth = rightPanel.offsetWidth;
            const leftPanelWidth = leftPanel.offsetWidth;
            const menuWidth = menu.offsetWidth;
            // Calculate max width for scrollable area: menu width - left panel - right panel - padding
            const maxScrollWidth = menuWidth - leftPanelWidth - rightPanelWidth - 20; // 20px for margins/padding
            // Constrain scrollable area so it doesn't extend under the right panel
            scrollableArea.style.maxWidth = maxScrollWidth + 'px';
            scrollableArea.style.flexShrink = '1';
        }
    }
    
    function toggleColMenu() { 
        const menu = document.getElementById('colMenu');
        const btn = document.querySelector('#burger-btn .settings-toggle.table-mode');
        const isActive = menu.classList.toggle('active');
        if (isActive) { 
            setTimeout(() => updateColMenuPosition(), 0); // Use setTimeout to ensure DOM is ready
            btn.classList.add('active'); 
        } else { 
            btn.classList.remove('active'); 
            saveSettings(false); 
        }
    }
    
    function toggleMainMenu() {
        const menu = document.getElementById('mainMenu');
        const btn = document.getElementById('btn-main-menu');
        const isActive = menu.classList.toggle('active');
        if (isActive) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    }
    
    // Update menu position on window resize
    window.addEventListener('resize', () => {
        const menu = document.getElementById('colMenu');
        if (menu && menu.classList.contains('active')) {
            updateColMenuPosition();
        }
        // NEVER recalculate on window resize - preserve manual adjustments
        // If user wants to recalculate, they can toggle a column
    });
    
    function toggleCol(chk) {
        const target = chk.getAttribute('data-target');
        const table = document.querySelector('.table-wrap');
        if (chk.checked) { 
            table.classList.remove('hide-' + target); 
        } else { 
            table.classList.add('hide-' + target); 
        }
        // ALWAYS force recalculation when columns are toggled to ensure all visible columns fit
        console.log('[COLUMN_WIDTHS] Column toggled:', target, 'checked:', chk.checked);
        hasSavedWidths = false; // Clear saved widths flag so calculation runs
        manualResizeBlocked = false; // Clear manual block when columns are toggled
        setTimeout(() => {
            calculateColumnWidths(true, true); // Force recalculation, allow override of manual block
        }, 100);
    }
    
    function applyVisibleCols(colList, skipRecalc = false) {
        if(!colList) return;
        const items = document.querySelectorAll('.col-chk-input');
        const table = document.querySelector('.table-wrap');
        const visibleSet = new Set(colList.split(','));
        
        items.forEach(chk => {
            const target = chk.getAttribute('data-target');
            if (visibleSet.has(target)) { chk.checked = true; table.classList.remove('hide-' + target); } 
            else { chk.checked = false; table.classList.add('hide-' + target); }
        });
        if (!skipRecalc) {
            // Force recalculation when columns are toggled (ignore saved widths)
            hasSavedWidths = false;
            setTimeout(() => calculateColumnWidths(true), 50);
        }
    }

    function getVisibleCols() {
        const visible = [];
        document.querySelectorAll('.col-chk-input').forEach(chk => {
            if(chk.checked) visible.push(chk.getAttribute('data-target'));
        });
        return visible.join(',');
    }

    function getSortOrder() {
        return `${sortCol}:${sortOrder}`;
    }

    function setSortOrder(sortStr) {
        if (!sortStr) return;
        const parts = sortStr.split(':');
        if (parts.length === 2) {
            sortCol = parts[0];
            sortOrder = parts[1];
            // Update sort icons
            document.querySelectorAll('.sort-icon').forEach(e => e.innerText = '');
            const arrow = sortOrder === 'asc' ? '▲' : '▼';
            const icon = document.getElementById('sort-' + sortCol);
            if(icon) icon.innerText = arrow;
        }
    }

    function getColumnOrder() {
        const headers = document.querySelectorAll('thead th');
        const order = [];
        headers.forEach(th => {
            const classes = Array.from(th.classList);
            const colClass = classes.find(c => c.startsWith('col-') && c !== 'col-chk' && c !== 'col-del');
            if (colClass) order.push(colClass);
        });
        return order;
    }

    function applyColumnOrder(order) {
        if (!order || !order.length) return;
        const table = document.querySelector('table');
        if (!table) return;
        const headerRow = table.querySelector('thead tr');
        const bodyRows = table.querySelectorAll('tbody tr');

        const reorderRow = (row) => {
            const cells = Array.from(row.children);
            const cellMap = {};
            cells.forEach(cell => {
                const classes = Array.from(cell.classList);
                if (classes.includes('col-chk')) cellMap['col-chk'] = cell;
                if (classes.includes('col-del')) cellMap['col-del'] = cell;
                const colClass = classes.find(c => c.startsWith('col-') && c !== 'col-chk' && c !== 'col-del');
                if (colClass) cellMap[colClass] = cell;
            });
            row.innerHTML = '';
            if (cellMap['col-chk']) row.appendChild(cellMap['col-chk']);
            order.forEach(col => {
                if (cellMap[col]) row.appendChild(cellMap[col]);
            });
            if (cellMap['col-del']) row.appendChild(cellMap['col-del']);
        };

        if (headerRow) reorderRow(headerRow);
        bodyRows.forEach(row => reorderRow(row));
    }

    function initColumnDrag() {
        if (columnDragInitialized) return;
        const headers = document.querySelectorAll('thead th');
        headers.forEach(th => {
            const classes = Array.from(th.classList);
            const colClass = classes.find(c => c.startsWith('col-') && c !== 'col-chk' && c !== 'col-del');
            if (!colClass) return;
            th.draggable = true;
            th.style.cursor = 'grab';
            th.addEventListener('dragstart', (e) => {
                th.classList.add('dragging');
                e.dataTransfer.setData('text/plain', colClass);
            });
            th.addEventListener('dragend', () => {
                th.classList.remove('dragging');
            });
            th.addEventListener('dragover', (e) => {
                e.preventDefault();
            });
            th.addEventListener('drop', (e) => {
                e.preventDefault();
                const source = e.dataTransfer.getData('text/plain');
                const target = colClass;
                if (!source || !target || source === target) return;
                const currentOrder = getColumnOrder();
                const nextOrder = currentOrder.filter(c => c !== source);
                const targetIndex = nextOrder.indexOf(target);
                if (targetIndex >= 0) {
                    nextOrder.splice(targetIndex, 0, source);
                    applyColumnOrder(nextOrder);
                    savedColumnOrder = nextOrder;
                    saveSettings(false);
                }
            });
        });
        columnDragInitialized = true;
    }

    function syncHeaderScrollbar() {
        const tableWrap = document.querySelector('.table-wrap');
        const tableScroll = document.querySelector('.table-scroll');
        const table = document.querySelector('table');
        const headerScrollbar = document.getElementById('header-scrollbar');
        const headerScrollbarPanel = document.getElementById('header-scrollbar-panel');
        const headerScrollbarInner = document.getElementById('header-scrollbar-inner');
        const thead = document.querySelector('thead');
        if (!tableWrap || !tableScroll || !table || !headerScrollbar || !headerScrollbarPanel || !headerScrollbarInner || !thead) return;
        const chkCell = table.querySelector('th.col-chk');
        const delCell = table.querySelector('th.col-del');
        const chkWidth = chkCell ? chkCell.offsetWidth : 40;
        const delWidth = delCell ? delCell.offsetWidth : 40;
        const available = Math.max(0, tableScroll.clientWidth - chkWidth - delWidth);
        const wrapRect = tableWrap.getBoundingClientRect();
        const theadRect = thead.getBoundingClientRect();
        const top = Math.max(0, Math.round(theadRect.bottom - wrapRect.top));
        headerScrollbarPanel.style.top = `${top}px`;
        headerScrollbar.style.marginLeft = `${chkWidth}px`;
        headerScrollbar.style.marginRight = `${delWidth}px`;
        headerScrollbar.style.width = `${available}px`;
        const innerWidth = Math.max(0, table.scrollWidth - chkWidth - delWidth);
        headerScrollbarInner.style.width = `${innerWidth}px`;
    }

    function initHeaderScrollbar() {
        const tableWrap = document.querySelector('.table-wrap');
        const tableScroll = document.querySelector('.table-scroll');
        const headerScrollbar = document.getElementById('header-scrollbar');
        const table = document.querySelector('table');
        if (!tableWrap || !tableScroll || !headerScrollbar) return;
        let syncing = false;
        headerScrollbar.addEventListener('scroll', () => {
            if (syncing) return;
            syncing = true;
            const maxTable = table ? Math.max(0, (table.scrollWidth - (tableScroll.clientWidth))) : 0;
            const maxHeader = Math.max(0, headerScrollbar.scrollWidth - headerScrollbar.clientWidth);
            const ratio = maxHeader > 0 ? headerScrollbar.scrollLeft / maxHeader : 0;
            tableScroll.scrollLeft = Math.round(maxTable * ratio);
            syncing = false;
        });
        tableScroll.addEventListener('scroll', () => {
            if (syncing) return;
            syncing = true;
            const maxTable = table ? Math.max(0, (table.scrollWidth - (tableScroll.clientWidth))) : 0;
            const maxHeader = Math.max(0, headerScrollbar.scrollWidth - headerScrollbar.clientWidth);
            const ratio = maxTable > 0 ? tableScroll.scrollLeft / maxTable : 0;
            headerScrollbar.scrollLeft = Math.round(maxHeader * ratio);
            syncing = false;
        });
        window.addEventListener('resize', () => syncHeaderScrollbar());
        syncHeaderScrollbar();
    }
    
    function getColumnWidths() {
        const widths = {};
        document.querySelectorAll('th[class*="col-"]').forEach(th => {
            const classes = th.className.split(' ');
            const colClass = classes.find(c => c.startsWith('col-') && c !== 'col-chk' && c !== 'col-del');
            if (colClass) {
                const computedStyle = window.getComputedStyle(th);
                const width = computedStyle.width;
                widths[colClass] = width;
            }
        });
        return widths;
    }
    
    function applyColumnWidths(widthsObj) {
        if (!widthsObj || typeof widthsObj !== 'object') {
            hasSavedWidths = false;
            isManualResize = false;
            return;
        }
        
        // Check if all visible columns have saved widths
        const table = document.querySelector('table');
        const tableWrap = document.querySelector('.table-wrap');
        if (table && tableWrap) {
            const visibleColumns = [];
            const headers = table.querySelectorAll('thead th');
            headers.forEach(th => {
                const classes = Array.from(th.classList);
                const colClass = classes.find(c => c.startsWith('col-') && c !== 'col-chk' && c !== 'col-del');
                if (colClass) {
                    const isHidden = tableWrap.classList.contains('hide-' + colClass);
                    if (!isHidden) {
                        visibleColumns.push(colClass);
                    }
                }
            });
            
            // Check if all visible columns have saved widths (and they're valid)
            const allHaveWidths = visibleColumns.length > 0 && visibleColumns.every(col => {
                const width = widthsObj[col];
                if (!width) return false;
                // Parse width value (could be "111px" or "111")
                const numWidth = parseFloat(width.toString().replace('px', ''));
                return numWidth > 0;
            });
            
            if (!allHaveWidths && visibleColumns.length > 0) {
                const missingCols = visibleColumns.filter(col => {
                    const width = widthsObj[col];
                    if (!width) return true;
                    const numWidth = parseFloat(width.toString().replace('px', ''));
                    return numWidth <= 0;
                });
                console.log('[COLUMN_WIDTHS] Saved widths missing or invalid for some columns, recalculating...');
                console.log('[COLUMN_WIDTHS] Visible columns:', visibleColumns);
                console.log('[COLUMN_WIDTHS] Saved widths keys:', Object.keys(widthsObj));
                console.log('[COLUMN_WIDTHS] Missing/invalid columns:', missingCols);
                hasSavedWidths = false;
                // Recalculate immediately to ensure all columns get widths
                // But respect manual resize block
                setTimeout(() => {
                    if (!manualResizeBlocked) {
                        calculateColumnWidths(true, false);
                    } else {
                        console.log('[COLUMN_WIDTHS] Skipping recalculate - manual resize is active');
                    }
                }, 50);
                return;
            }
        }
        
        // Only set hasSavedWidths if there are actual widths to apply
        const hasWidths = Object.keys(widthsObj).length > 0;
        hasSavedWidths = hasWidths;
        isManualResize = false; // Not a manual resize, just loading saved widths
        document.querySelectorAll('th[class*="col-"], td[class*="col-"]').forEach(cell => {
            const classes = cell.className.split(' ');
            const colClass = classes.find(c => c.startsWith('col-') && c !== 'col-chk' && c !== 'col-del');
            if (colClass && widthsObj[colClass]) {
                cell.style.width = widthsObj[colClass];
                cell.style.minWidth = widthsObj[colClass];
                cell.style.maxWidth = widthsObj[colClass];
            }
        });
    }
    
    // Column Resize
    let isResizing = false;
    let resizeColumn = null;
    let startX = 0;
    let startWidth = 0;
    let columnResizeActive = false;
    
    function lockVisibleColumnWidths() {
        const table = document.querySelector('table');
        const tableWrap = document.querySelector('.table-wrap');
        if (!table || !tableWrap) return;
        const headers = table.querySelectorAll('thead th');
        headers.forEach(th => {
            const classes = Array.from(th.classList);
            const colClass = classes.find(c => c.startsWith('col-') && c !== 'col-chk' && c !== 'col-del');
            if (!colClass) return;
            const isHidden = tableWrap.classList.contains('hide-' + colClass);
            if (isHidden) return;
            const width = `${th.offsetWidth}px`;
            if (!width) return;
            document.querySelectorAll(`th.${colClass}, td.${colClass}`).forEach(cell => {
                cell.style.width = width;
                cell.style.minWidth = width;
                cell.style.maxWidth = width;
            });
        });
    }
    
    function initColumnResize() {
        const tableScroll = document.querySelector('.table-scroll');
        document.querySelectorAll('th[class*="col-"]:not(.col-chk):not(.col-del)').forEach(th => {
            th.addEventListener('mousedown', (e) => {
                const rect = th.getBoundingClientRect();
                const handleWidth = 4;
                const isOnHandle = e.clientX >= rect.right - handleWidth;
                
                if (isOnHandle) {
                    columnResizeActive = true;
                    lockVisibleColumnWidths();
                    isResizing = true;
                    resizeColumn = th;
                    startX = e.pageX + (tableScroll ? tableScroll.scrollLeft : 0);
                    startWidth = th.offsetWidth;
                    document.body.style.cursor = 'col-resize';
                    document.body.style.userSelect = 'none';
                    e.preventDefault();
                }
            });
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isResizing || !resizeColumn) return;
            
            const classes = resizeColumn.className.split(' ');
            const colClass = classes.find(c => c.startsWith('col-') && c !== 'col-chk' && c !== 'col-del');
            if (!colClass) return;
            
            const currentX = e.pageX + (tableScroll ? tableScroll.scrollLeft : 0);
            const diff = currentX - startX;
            const newWidth = Math.max(30, startWidth + diff); // Minimum 30px
            const newWidthStr = newWidth + 'px';
            
            // Immediately apply the resize
            document.querySelectorAll(`th.${colClass}, td.${colClass}`).forEach(cell => {
                cell.style.width = newWidthStr;
                cell.style.minWidth = newWidthStr;
                cell.style.maxWidth = newWidthStr;
            });
            
            // Mark as manually resizing to prevent recalculation during resize
            isManualResize = true;
        });
        
        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                resizeColumn = null;
                
                // Mark that we have manually set widths - BLOCK all automatic recalculations
                hasSavedWidths = true;
                isManualResize = false; // Resize complete
                manualResizeBlocked = true; // BLOCK automatic recalculations from now on
                
                // Save widths immediately after resize (without triggering data reload)
                // Get current widths and save them directly to server
                const currentWidths = getColumnWidths();
                fetch('/api/settings', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({column_widths: JSON.stringify(currentWidths)})
                }).then(() => {
                    console.log('[COLUMN_WIDTHS] Manual resize widths saved to server, automatic recalculation BLOCKED');
                    hasSavedWidths = true;
                }).catch(e => {
                    console.error('[COLUMN_WIDTHS] Failed to save widths:', e);
                });
                
                console.log('[COLUMN_WIDTHS] Manual resize completed - automatic recalculation is now BLOCKED');
            }
            if (columnResizeActive) {
                setTimeout(() => { columnResizeActive = false; }, 150);
            }
        });
    }

    // --- COLUMN WIDTH CALCULATION ---
    let hasSavedWidths = false;
    let isManualResize = false; // Track if user is manually resizing
    let manualResizeBlocked = false; // Block ALL automatic recalculations after manual resize
    
    function calculateColumnWidths(forceRecalculate = false, allowOverrideManual = false) {
        // NEVER run if manual resize was used (user wants manual control)
        // UNLESS explicitly allowed (e.g., from column toggle)
        if (manualResizeBlocked && !allowOverrideManual) {
            console.log('[COLUMN_WIDTHS] Skipping - manual resize is active, user controls widths (forceRecalculate:', forceRecalculate, ')');
            return;
        }
        
        // Clear manual block ONLY when explicitly allowed (e.g., column toggle)
        if (forceRecalculate && allowOverrideManual) {
            manualResizeBlocked = false; // Clear manual block when columns are toggled
            console.log('[COLUMN_WIDTHS] Manual block cleared - column toggle detected');
        }
        
        console.log('[COLUMN_WIDTHS] Calculating widths, forceRecalculate:', forceRecalculate, 'hasSavedWidths:', hasSavedWidths, 'isManualResize:', isManualResize);
        
        const table = document.querySelector('table');
        const tableWrap = document.querySelector('.table-wrap');
        const tableScroll = document.querySelector('.table-scroll');
        if (!table || !tableWrap || !tableScroll) return;
        
        // Get table width (excluding checkbox and hamburger columns)
        const tableWidth = tableScroll.offsetWidth;
        const checkboxWidth = 40; // col-chk width
        const hamburgerWidth = 40; // col-del width
        const availableWidth = tableWidth - checkboxWidth - hamburgerWidth;
        
        // Column priority weights (higher = more space allocated)
        const columnWeights = {
            'col-file': 1.8,      // Filename gets most space (reduced from 3.0 to prevent hogging)
            'col-main': 1.2,      // Format
            'col-prof': 1.0,      // Profile
            'col-el': 0.8,        // EL Type
            'col-sec': 1.0,       // Secondary
            'col-res': 0.9,       // Resolution
            'col-bit': 0.8,       // Bitrate
            'col-size': 0.9,      // Size
            'col-width': 0.6,     // Width
            'col-height': 0.6,    // Height
            'col-vol': 0.7,       // Volume
            'col-cont': 0.6,      // Container
            'col-scan': 0.8,      // Scanned
            'col-stat': 0.7,     // Status
            'col-hyb': 0.6,       // Hybrid
            'col-audio': 1.0,     // Audio
            'col-sub': 0.7,       // Subtitles
            'col-cll': 0.7,       // MaxCLL
            'col-fall': 0.7,      // MaxFALL
            'col-video-source': 0.8,    // Source
            'col-source-format': 0.8,  // Source Format
            'col-video-codec': 0.8,    // Codec
            'col-is-3d': 0.5,     // 3D
            'col-edition': 0.9,   // Edition
            'col-year': 0.5,      // Year
            'col-media-type': 0.6, // Media Type
            'col-show-title': 1.2, // Show Title
            'col-season': 0.5,    // Season
            'col-episode': 0.5,   // Episode
            'col-movie-title': 1.2, // Movie Title
            'col-episode-title': 1.2 // Episode Title
        };
        
        // Get all visible columns (excluding checkbox and hamburger)
        const visibleColumns = [];
        const headers = table.querySelectorAll('thead th');
        headers.forEach(th => {
            const classes = Array.from(th.classList);
            const colClass = classes.find(c => c.startsWith('col-') && c !== 'col-chk' && c !== 'col-del');
            if (colClass) {
                // Check if column is actually visible (not hidden)
                const isHidden = tableWrap.classList.contains('hide-' + colClass);
                if (!isHidden) {
                    visibleColumns.push(colClass);
                }
            }
        });
        
        // Calculate total weight
        let totalWeight = 0;
        visibleColumns.forEach(col => {
            totalWeight += columnWeights[col] || 0.7; // Default weight if not found
        });
        
        if (totalWeight === 0) {
            console.warn('[COLUMN_WIDTHS] No visible columns found!');
            return; // No visible columns
        }
        
        console.log('[COLUMN_WIDTHS] Found', visibleColumns.length, 'visible columns:', visibleColumns.join(', '));
        
        // Calculate proportional widths first
        const calculatedWidths = {};
        const minWidths = {};
        let totalMinWidth = 0;
        
        // First pass: calculate min widths - keep them small to ensure all columns fit
        visibleColumns.forEach(col => {
            const minWidth = col === 'col-file' ? 100 : (col.includes('year') || col.includes('3d') ? 40 : 50);
            minWidths[col] = minWidth;
            totalMinWidth += minWidth;
        });
        
        // Check if we have enough space for minimum widths
        if (totalMinWidth > availableWidth) {
            // Not enough space - distribute equally to ensure ALL columns are visible
            const equalWidth = Math.floor(availableWidth / visibleColumns.length);
            visibleColumns.forEach(col => {
                calculatedWidths[col] = Math.max(equalWidth, 30); // Minimum 30px per column
            });
        } else {
            // We have enough space - distribute remaining width proportionally but ensure ALL columns fit
            const remainingWidth = availableWidth - totalMinWidth;
            
            // Distribute remaining space proportionally
            visibleColumns.forEach(col => {
                const weight = columnWeights[col] || 0.7;
                const proportionalShare = (remainingWidth * weight) / totalWeight;
                calculatedWidths[col] = Math.floor(minWidths[col] + proportionalShare);
            });
            
            // CRITICAL: Ensure total EXACTLY matches available width (or is less)
            let totalCalculated = visibleColumns.reduce((sum, col) => sum + calculatedWidths[col], 0);
            
            if (totalCalculated > availableWidth) {
                // Total exceeds available - reduce proportionally to fit exactly
                const scaleFactor = availableWidth / totalCalculated;
                visibleColumns.forEach(col => {
                    const scaled = Math.floor(calculatedWidths[col] * scaleFactor);
                    // Ensure it's at least the minimum
                    calculatedWidths[col] = Math.max(scaled, minWidths[col]);
                });
                // Recalculate total after scaling
                totalCalculated = visibleColumns.reduce((sum, col) => sum + calculatedWidths[col], 0);
            }
            
            // Final adjustment: if still over, trim from largest columns
            if (totalCalculated > availableWidth) {
                const diff = totalCalculated - availableWidth;
                const sortedCols = [...visibleColumns].sort((a, b) => calculatedWidths[b] - calculatedWidths[a]);
                let trimmed = 0;
                for (const col of sortedCols) {
                    if (trimmed >= diff) break;
                    if (calculatedWidths[col] > minWidths[col]) {
                        const trim = Math.min(calculatedWidths[col] - minWidths[col], diff - trimmed);
                        calculatedWidths[col] -= trim;
                        trimmed += trim;
                    }
                }
            } else if (totalCalculated < availableWidth) {
                // If under, add to filename column
                const diff = availableWidth - totalCalculated;
                const fileCol = visibleColumns.find(col => col === 'col-file');
                if (fileCol) {
                    calculatedWidths[fileCol] += diff;
                }
            }
        }
        
        // Final check: ensure total exactly equals availableWidth
        let totalCalculated = visibleColumns.reduce((sum, col) => sum + (calculatedWidths[col] || 0), 0);
        if (totalCalculated !== availableWidth && totalCalculated > 0 && visibleColumns.length > 0) {
            // Adjust to match exactly
            const diff = availableWidth - totalCalculated;
            if (diff > 0) {
                // Add to filename column if it exists, otherwise first column
                const fileCol = visibleColumns.find(col => col === 'col-file');
                if (fileCol) {
                    calculatedWidths[fileCol] = (calculatedWidths[fileCol] || 0) + diff;
                } else {
                    calculatedWidths[visibleColumns[0]] = (calculatedWidths[visibleColumns[0]] || 0) + diff;
                }
            } else {
                // Subtract from largest columns
                const sortedCols = [...visibleColumns].sort((a, b) => (calculatedWidths[b] || 0) - (calculatedWidths[a] || 0));
                let toRemove = Math.abs(diff);
                for (const col of sortedCols) {
                    if (toRemove <= 0) break;
                    const current = calculatedWidths[col] || 0;
                    const min = minWidths[col] || 30;
                    if (current > min) {
                        const remove = Math.min(current - min, toRemove);
                        calculatedWidths[col] = current - remove;
                        toRemove -= remove;
                    }
                }
            }
        }
        
        // Apply widths - ensure ALL columns get a width
        let totalApplied = 0;
        visibleColumns.forEach(col => {
            const finalWidth = calculatedWidths[col] || 50; // Fallback to 50px if undefined
            totalApplied += finalWidth;
            
            // Apply to all cells with this class
            document.querySelectorAll(`th.${col}, td.${col}`).forEach(cell => {
                cell.style.width = finalWidth + 'px';
                cell.style.minWidth = finalWidth + 'px';
                cell.style.maxWidth = finalWidth + 'px';
            });
        });
        
        // Debug: Log results and verify columns are actually visible
        console.log(`[COLUMN_WIDTHS] Applied ${visibleColumns.length} columns: ${totalApplied}px / ${availableWidth}px`);
        console.log(`[COLUMN_WIDTHS] Column widths:`, visibleColumns.map(col => `${col}:${calculatedWidths[col] || 0}px`).join(', '));
        
        // Verify all columns are actually visible in the DOM
        visibleColumns.forEach(col => {
            const cells = document.querySelectorAll(`th.${col}, td.${col}`);
            if (cells.length === 0) {
                console.error(`[COLUMN_WIDTHS] ERROR: Column ${col} has no cells in DOM!`);
            } else {
                const firstCell = cells[0];
                const computedWidth = window.getComputedStyle(firstCell).width;
                const expectedWidth = calculatedWidths[col] + 'px';
                const isVisible = window.getComputedStyle(firstCell).display !== 'none';
                if (!isVisible) {
                    console.error(`[COLUMN_WIDTHS] ERROR: Column ${col} is hidden (display: none)!`);
                } else if (computedWidth !== expectedWidth) {
                    console.warn(`[COLUMN_WIDTHS] WARNING: Column ${col} width mismatch! Expected: ${expectedWidth}, Got: ${computedWidth}`);
                }
            }
        });
        
        if (totalApplied > availableWidth + 5) {
            console.error(`[COLUMN_WIDTHS] ERROR: Total ${totalApplied}px exceeds available ${availableWidth}px!`);
        } else {
            console.log(`[COLUMN_WIDTHS] SUCCESS: All ${visibleColumns.length} columns should be visible!`);
        }
    }

    // --- CHART LOGIC ---
    function updateCharts(statsTotal, statsFiltered, filterOpts) {
        const stats = chartMode === 'filtered' && statsFiltered ? statsFiltered : statsTotal;
        if (!stats || !stats.vol_labels) return;

        const paletteKey = document.getElementById('palette-select').value;
        let currentPalette = PALETTES[paletteKey] || PALETTES.all;
        // If we need more colors than available in the palette, generate them dynamically
        if (stats.vol_labels.length > currentPalette.length) {
            const generatedColors = generateColors(stats.vol_labels.length, paletteKey === 'all' ? 'vibrant' : paletteKey);
            currentPalette = [...currentPalette, ...generatedColors.slice(currentPalette.length)];
        }
        const volColors = stats.vol_labels.map((_, i) => currentPalette[i]);
        const resColors = stats.res_labels.map(label => RES_COLORS[label] || '#555555');

        if (formatChart) formatChart.destroy();
        formatChart = new Chart(document.getElementById('formatChart'), {
            type: 'doughnut',
            data: {
                labels: ['DV P7 FEL', 'DV P7 MEL', 'DV P8.1', 'DV P8.4', 'DV P5', 'HDR10+', 'HDR10', 'HLG', 'SDR'],
                datasets: [{ 
                    data: [stats.dovi_p7_fel, stats.dovi_p7_mel, (stats.dovi_p81 + stats.dovi_p8), stats.dovi_p84, stats.dovi_p5, stats.hdr10plus, stats.hdr10, stats.hlg, stats.sdr], 
                    backgroundColor: ['#a55eea', '#5f27cd', '#e74c3c', '#fd79a8', '#27ae60', '#f1c40f', '#e67e22', '#3498db', '#555555'], borderWidth: 0 
                }]
            },
            options: { 
                responsive: true, maintainAspectRatio: false,
                onClick: (evt, elements) => {
                    if (elements.length > 0) {
                        const label = formatChart.data.labels[elements[0].index];
                        if (label.includes('DV')) {
                            if (label.includes('FEL')) setFilter('el', 'FEL');
                            else if (label.includes('MEL')) setFilter('el', 'MEL');
                            else if (label.includes('P5')) { setFilter('format', 'dovi'); const el = document.getElementById('profile-filter-header'); if (el) el.value = '5'; resetAndLoad(); }
                            else if (label.includes('P8.1')) { setFilter('format', 'dovi'); const el = document.getElementById('profile-filter-header'); if (el) el.value = '8.1'; resetAndLoad(); }
                            else if (label.includes('P8.4')) { setFilter('format', 'dovi'); const el = document.getElementById('profile-filter-header'); if (el) el.value = '8.4'; resetAndLoad(); }
                        } else if (label === 'HDR10+') setFilter('format', 'hdr10plus');
                        else if (label === 'HDR10') setFilter('format', 'hdr10');
                        else if (label === 'HLG') setFilter('format', 'hlg');
                        else if (label === 'SDR') setFilter('format', 'sdr_only');
                    }
                },
                plugins: { legend: { position: 'right', labels: { color: '#fff', font: { size: 10 }, padding: 10 } }, title: { display: false } } 
            }
        });

        if (secChart) secChart.destroy();
        let secLabels = [], secData = [], secColors = [];
        const secColorMap = { 'HDR10+': '#f1c40f', 'HDR10': '#e67e22', 'HLG': '#3498db', 'none': '#333' };
        if (stats.secondary_hdrs) {
            Object.entries(stats.secondary_hdrs).forEach(([key, val]) => {
                if (key !== 'none') { secLabels.push(key.toUpperCase()); secData.push(val); secColors.push(secColorMap[key] || '#999'); }
            });
        }
        secChart = new Chart(document.getElementById('secChart'), {
            type: 'doughnut',
            data: { labels: secLabels, datasets: [{ data: secData, backgroundColor: secColors, borderWidth: 0 }] },
            options: { 
                responsive: true, maintainAspectRatio: false,
                onClick: (evt, elements) => { if (elements.length > 0) { const label = secChart.data.labels[elements[0].index]; let val = label; if(label === 'HDR10+') val = 'HDR10+'; const el = document.getElementById('secondary-filter-header'); if (el) el.value = val; resetAndLoad(); } },
                plugins: { legend: { position: 'right', labels: { color: '#fff', font: { size: 10 }, padding: 10 } }, title: { display: false } } 
            }
        });
        
        if (resChart) resChart.destroy();
        resChart = new Chart(document.getElementById('resChart'), {
            type: 'doughnut', 
            data: { labels: stats.res_labels, datasets: [{ data: stats.res_data, backgroundColor: resColors, borderWidth: 0 }] },
            options: { 
                responsive: true, maintainAspectRatio: false,
                onClick: (evt, elements) => { if (elements.length > 0) { setFilter('resolution', stats.res_labels[elements[0].index]); } },
                plugins: { legend: { position: 'right', labels: { color: '#fff', font: { size: 10 }, padding: 10 } }, title: { display: false } } 
            }
        });

        if (volChart) volChart.destroy();
        volChart = new Chart(document.getElementById('volChart'), {
            type: 'bar',
            data: { labels: stats.vol_labels, datasets: [{ label: 'Files', data: stats.vol_data, backgroundColor: volColors }] },
            options: { 
                responsive: true, maintainAspectRatio: false, layout: { padding: { top: 40 } }, 
                onClick: (evt, elements) => { if (elements.length > 0) { const el = document.getElementById('vol-filter-header'); if (el) el.value = stats.vol_labels[elements[0].index]; resetAndLoad(); } },
                scales: { y: { beginAtZero: true, grid: { color: '#222' } }, x: { ticks: { color: '#888', font: { size: 9 } } } }, 
                plugins: { legend: { display: false }, title: { display: false } } 
            }
        });
    }

    function updateFilterDropdowns(opts) {
        if (!opts) return;
        
        // Update format multiselect
        lastFilterOptions = opts;
        lastFilterBlanks = opts.blank_counts || {};
        updateFormatMultiselect(opts.categories);
        
        // Update all other multiselects
        updateMultiselectOptions('profile-filter', opts.profiles, {}, lastFilterBlanks.profile);
        updateMultiselectOptions('el-filter', opts.el_types, {}, lastFilterBlanks.el);
        updateMultiselectOptions('vol-filter', opts.volumes, {}, lastFilterBlanks.volume);
        updateMultiselectOptions('container-filter', opts.containers, {}, lastFilterBlanks.container);
        updateMultiselectOptions('secondary-filter', opts.secondary_hdrs, {}, lastFilterBlanks.secondary_hdr);
        updateMultiselectOptions('res-filter', opts.resolutions, {}, lastFilterBlanks.resolution);
        updateMultiselectOptions('audio-filter', opts.audio_codecs, {}, lastFilterBlanks.audio);
        updateMultiselectOptions('video-source-filter', opts.video_sources, {}, lastFilterBlanks.video_source);
        updateMultiselectOptions('source-format-filter', opts.source_formats, {}, lastFilterBlanks.source_format);
        updateMultiselectOptions('video-codec-filter', opts.video_codecs, {}, lastFilterBlanks.video_codec);
        updateMultiselectOptions('edition-filter', opts.editions, {}, lastFilterBlanks.edition);
        updateMultiselectOptions('media-type-filter', opts.media_types, { movie: 'MOVIE', tv: 'TV' }, lastFilterBlanks.media_type);
        
        // Update single-select dropdowns (hybrid, status)
        const update = (id, options) => {
            if (!options) return; 
            const el = document.getElementById(id); if (!el) return; 
            const current = el.value; 
            let items = Array.isArray(options) ? options : Object.keys(options);
            if (current && !Array.isArray(options) && options[current] === undefined) { options[current] = 0; }
            if (current && !Array.isArray(options) && !items.includes(current)) { items.push(current); }
            let html = `<option value="">All</option>`;
            html += items.map(k => {
                let val = k.toString();
                let display = val.toUpperCase();
                if(val === 'sdr_only') display = 'SDR';
                if(val === 'hdr10plus') display = 'HDR10+';
                if(val === 'none') display = 'None'; 
                let count = (opts && !Array.isArray(options) && options[val] !== undefined) ? options[val] : 0;
                if (!Array.isArray(options)) { 
                    if (count === 0 && val !== current) return ''; 
                    display += ` (${count})`; 
                }
                return `<option value="${val}" ${val == current ? 'selected' : ''}>${display}</option>`;
            }).join('');
            if (current && current !== '' && !Array.isArray(options)) {
                const hasCurrentValue = html.includes(`value="${current}"`);
                if (!hasCurrentValue) {
                    let display = current.toUpperCase();
                    if(current === 'sdr_only') display = 'SDR';
                    if(current === 'hdr10plus') display = 'HDR10+';
                    if(current === 'none') display = 'None';
                    html += `<option value="${current}" selected>${display} (0)</option>`;
                }
            }
            el.innerHTML = html; 
            if (current) el.value = current; 
        }; 

        const hybEl = document.getElementById('hybrid-filter-header');
        if (hybEl) {
            const hybCur = hybEl.value; const hybCounts = opts.special_hybrid || { '1': 0, '0': 0 };
            let hybHtml = `<option value="">All</option>`;
            // Always include current value even if count is 0
            if (hybCur === "1" || hybCounts['1'] > 0) hybHtml += `<option value="1" ${hybCur === "1" ? "selected" : ""}>Hybrid (${hybCounts['1'] || 0})</option>`;
            if (hybCur === "0" || hybCounts['0'] > 0) hybHtml += `<option value="0" ${hybCur === "0" ? "selected" : ""}>Standard (${hybCounts['0'] || 0})</option>`;
            hybEl.innerHTML = hybHtml;
            if (hybCur) hybEl.value = hybCur;
        }
        
        const d3dEl = document.getElementById('is-3d-filter-header');
        if (d3dEl) {
            const d3dCur = d3dEl.value; const d3dCounts = opts.special_is_3d || { '1': 0, '0': 0 };
            let d3dHtml = `<option value="">All</option>`;
            // Always include current value even if count is 0
            if (d3dCur === "1" || d3dCounts['1'] > 0) d3dHtml += `<option value="1" ${d3dCur === "1" ? "selected" : ""}>3D (${d3dCounts['1'] || 0})</option>`;
            if (d3dCur === "0" || d3dCounts['0'] > 0) d3dHtml += `<option value="0" ${d3dCur === "0" ? "selected" : ""}>2D (${d3dCounts['0'] || 0})</option>`;
            d3dEl.innerHTML = d3dHtml;
            if (d3dCur) d3dEl.value = d3dCur;
        }

        const statEl = document.getElementById('status-filter-header');
        if (statEl) {
            const statCur = statEl.value; const statCounts = opts.special_status || { 'ok': 0, 'failed': 0 };
            let statHtml = `<option value="">All</option>`;
            // Always include current value even if count is 0
            if (statCur === "ok" || statCounts['ok'] > 0) statHtml += `<option value="ok" ${statCur === "ok" ? "selected" : ""}>OK (${statCounts['ok'] || 0})</option>`;
            if (statCur === "failed" || statCounts['failed'] > 0) statHtml += `<option value="failed" ${statCur === "failed" ? "selected" : ""}>Failed (${statCounts['failed'] || 0})</option>`;
            statEl.innerHTML = statHtml;
            if (statCur) statEl.value = statCur;
        }
    }

    // --- DATA LOADING & INTERACTION ---
    function debounceSearch() { clearTimeout(searchTimer); searchTimer = setTimeout(resetAndLoad, 400); }
    function resetAndLoad() { currentPage = 1; loadData(); }
    function changePage(d) { jumpPage(currentPage + d); }
    function jumpPage(v) { currentPage = Math.max(1, Math.min(totalPages, parseInt(v) || 1)); loadData(); }

    function updateSelectedRowHighlight() {
        const tbody = document.getElementById('video-table-body');
        if (!tbody) return;
        const rows = Array.from(tbody.querySelectorAll('tr'));
        rows.forEach(r => r.classList.remove('keyboard-selected'));
        if (selectedRowIndex < 0 || selectedRowIndex >= rows.length) return;
        const row = rows[selectedRowIndex];
        if (row) {
            row.classList.add('keyboard-selected');
            row.scrollIntoView({ block: 'nearest' });
        }
    }

    function selectRowByIndex(index) {
        selectedRowIndex = index;
        updateSelectedRowHighlight();
    }

    let contextMenuPath = '';

    function handleRowClick(evt, index, path) {
        if (evt && (evt.ctrlKey || evt.metaKey)) {
            const row = evt.currentTarget;
            const chk = row ? row.querySelector('input.row-chk') : null;
            if (chk) {
                chk.checked = !chk.checked;
                toggleRow(chk, path);
            }
        }
        selectRowByIndex(index);
    }

    function openRowContextMenu(evt, index, path) {
        if (!evt) return;
        evt.preventDefault();
        const row = evt.currentTarget;
        const chk = row ? row.querySelector('input.row-chk') : null;
        if (chk && !chk.checked) {
            chk.checked = true;
            toggleRow(chk, path);
        }
        selectRowByIndex(index);
        contextMenuPath = path;
        const menu = document.getElementById('row-context-menu');
        if (!menu) return;
        menu.style.left = `${evt.pageX}px`;
        menu.style.top = `${evt.pageY}px`;
        menu.classList.add('active');
    }

    function closeContextMenu() {
        const menu = document.getElementById('row-context-menu');
        if (menu) menu.classList.remove('active');
    }

    function contextRescan() {
        closeContextMenu();
        if (selectedPaths.size > 1) {
            bulkRescanSelected();
            return;
        }
        if (contextMenuPath) {
            rescanFile(contextMenuPath);
        }
    }

    function contextCopyPath() {
        closeContextMenu();
        if (!contextMenuPath) return;
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(contextMenuPath).then(() => showToast('Path copied'));
        } else {
            showToast('Copy not supported');
        }
    }

    function selectAllRows() {
        closeContextMenu();
        masterState = 1;
        const chkEl = document.getElementById('master-chk');
        if (chkEl) chkEl.className = 'col-chk master-dash';
        currentRows.forEach(p => selectedPaths.add(p));
        document.querySelectorAll('.row-chk').forEach(c => c.checked = true);
        updateDeleteBtn();
    }

    function selectAllFilteredRows() {
        closeContextMenu();
        masterState = 2;
        const chkEl = document.getElementById('master-chk');
        if (chkEl) chkEl.className = 'col-chk master-x';
        selectedPaths.clear();
        document.querySelectorAll('.row-chk').forEach(c => c.checked = false);
        updateDeleteBtn();
    }

    function deselectAllRows() {
        closeContextMenu();
        masterState = 0;
        const chkEl = document.getElementById('master-chk');
        if (chkEl) chkEl.className = 'col-chk';
        selectedPaths.clear();
        document.querySelectorAll('.row-chk').forEach(c => c.checked = false);
        updateDeleteBtn();
    }

    function moveRowSelection(delta) {
        const tbody = document.getElementById('video-table-body');
        const rows = tbody ? tbody.querySelectorAll('tr') : [];
        if (!rows.length) return;
        if (selectedRowIndex < 0) selectedRowIndex = 0;
        selectedRowIndex = Math.max(0, Math.min(rows.length - 1, selectedRowIndex + delta));
        updateSelectedRowHighlight();
    }

    function isTypingTarget(target) {
        if (!target) return false;
        const tag = target.tagName;
        return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || target.isContentEditable;
    }

    function formatSearchValue(value) {
        if (value.includes(' ')) {
            return `"${value}"`;
        }
        return value;
    }

    function getSearchSuggestionValues(token) {
        const opts = lastFilterOptions || {};
        const values = {
            'year': [],
            'source': Object.keys(opts.video_sources || {}),
            'format': Object.keys(opts.source_formats || {}),
            'codec': Object.keys(opts.video_codecs || {}),
            'res': Object.keys(opts.resolutions || {}),
            'resolution': Object.keys(opts.resolutions || {}),
            'category': Object.keys(opts.categories || {}),
            'cat': Object.keys(opts.categories || {}),
            'volume': Object.keys(opts.volumes || {}),
            'vol': Object.keys(opts.volumes || {}),
            'container': Object.keys(opts.containers || {}),
            'edition': Object.keys(opts.editions || {}),
            'type': ['movie', 'tv'],
            'media_type': ['movie', 'tv'],
            'status': ['ok', 'failed'],
            'hybrid': ['1', '0'],
            '3d': ['1', '0']
        };
        return values[token] || [];
    }

    function updateSearchSuggestions() {
        const input = document.getElementById('search-bar');
        const suggestionsEl = document.getElementById('search-suggestions');
        if (!input || !suggestionsEl) return;
        const value = input.value || '';
        const parts = value.split(/\s+/);
        const last = parts[parts.length - 1] || '';
        const tokens = ['year', 'source', 'format', 'codec', 'res', 'resolution', 'category', 'cat', 'volume', 'vol', 'container', 'edition', 'type', 'media_type', 'status', 'hybrid', '3d'];

        let suggestions = [];
        if (last.includes(':')) {
            const [tokenRaw, ...rest] = last.split(':');
            const token = tokenRaw.toLowerCase();
            const partial = rest.join(':');
            const values = getSearchSuggestionValues(token);
            suggestions = values
                .map(v => formatSearchValue(v))
                .filter(v => v.toLowerCase().startsWith(partial.toLowerCase()))
                .map(v => `${token}:${v}`);
        } else {
            suggestions = tokens
                .filter(t => t.startsWith(last.toLowerCase()))
                .map(t => `${t}:`);
        }

        if (suggestions.length === 0) {
            suggestionsEl.style.display = 'none';
            suggestionsEl.innerHTML = '';
            return;
        }

        suggestionsEl.innerHTML = suggestions.slice(0, 20).map(s => `<div class="search-suggestion" data-value="${s}">${s}</div>`).join('');
        suggestionsEl.style.display = 'block';
    }

    function applySearchSuggestion(value) {
        const input = document.getElementById('search-bar');
        const suggestionsEl = document.getElementById('search-suggestions');
        if (!input) return;
        const parts = input.value.split(/\s+/);
        parts[parts.length - 1] = value;
        input.value = parts.join(' ') + ' ';
        if (suggestionsEl) {
            suggestionsEl.style.display = 'none';
            suggestionsEl.innerHTML = '';
        }
        debounceSearch();
    }
    
    function toggleCharts() {
        const view = document.getElementById('db-view');
        const btn = document.getElementById('btn-toggle-charts');
        if (view.style.display === 'none' || view.style.display === '') {
            view.style.display = 'grid'; 
            btn.innerHTML = 'Charts ⏷'; 
            loadData(); 
        } else {
            view.style.display = 'none'; 
            btn.innerHTML = 'Charts ⏵';
        }
    }
    
    function toggleFormatView() {
        const mainView = document.getElementById('view-main-fmt');
        const secView = document.getElementById('view-sec-fmt');
        if (mainView.classList.contains('active')) {
            mainView.classList.remove('active'); mainView.classList.add('hidden');
            secView.classList.remove('hidden'); secView.classList.add('active');
        } else {
            secView.classList.remove('active'); secView.classList.add('hidden');
            mainView.classList.remove('hidden'); mainView.classList.add('active');
        }
    }

    function toggleChartMode() {
        chartMode = chartMode === 'total' ? 'filtered' : 'total';
        const toggle = document.getElementById('chart-mode-toggle');
        if (toggle) {
            toggle.innerText = chartMode === 'total' ? 'Totals' : 'Filtered';
        }
        if (lastStats) {
            updateCharts(lastStats, lastStatsFiltered, lastFilterOptions);
        }
    }

    function applyStatsToUI(stats, totalItems) {
        if (!stats) return;
        document.getElementById('stat-total').innerText = stats.total ?? 0;
        document.getElementById('stat-failed').innerText = stats.failed ?? 0;
        document.getElementById('stat-hybrid').innerText = stats.hybrid ?? 0;
        document.getElementById('stat-dovi').innerText = stats.dovi ?? 0;
        document.getElementById('stat-hdr10plus').innerText = stats.hdr10plus ?? 0;
        document.getElementById('stat-hdr10').innerText = stats.hdr10 ?? 0;
        document.getElementById('stat-hlg').innerText = stats.hlg ?? 0;
        document.getElementById('stat-sdr').innerText = stats.sdr ?? 0;
        document.getElementById('stat-fel').innerText = stats.dovi_p7_fel ?? 0;
        document.getElementById('stat-mel').innerText = stats.dovi_p7_mel ?? 0;
        document.getElementById('stat-p81').innerText = stats.dovi_p81 || 0;
        document.getElementById('stat-p84').innerText = stats.dovi_p84 || 0;
        document.getElementById('res-total-display').innerText = stats.total ?? 0;
        if (typeof totalItems === 'number') {
            document.getElementById('res-filtered').innerText = totalItems;
        }
        // Only update duration from stats if not currently scanning (to avoid resetting live timer)
        if (!document.body.classList.contains('scanning')) {
            document.getElementById('stat-duration').innerText = formatDuration(stats.last_scan_time || '0s');
        }
    }

    async function loadData() {
        // Don't load data if we're in the middle of clearing filters
        if (isClearingFilters) {
            console.log(`[DEBUG] loadData(): Skipping because isClearingFilters=true`);
            return;
        }
        if (isLoading) return;
        isLoading = true;
        
        activeFilters.search = document.getElementById('search-bar') ? document.getElementById('search-bar').value : '';
        try { 
            console.log(`[DEBUG] loadData(): About to call getFormatFilterValue(), pendingFormatValue = "${pendingFormatValue}"`);
            const formatValue = getFormatFilterValue();
            console.log(`[DEBUG] loadData(): getFormatFilterValue() returned = "${formatValue}"`);
            activeFilters.category = formatValue;
            // Clear pending value after it's been read by loadData()
            if (pendingFormatValue && formatValue === pendingFormatValue) {
                console.log(`[DEBUG] loadData(): Clearing pendingFormatValue after reading`);
                pendingFormatValue = null;
            }
            // Debug: log if format filter is set but empty string is returned
            if (formatValue === '' && document.querySelectorAll('#format-filter-dropdown input[type="checkbox"]:not(#format-chk-all):checked').length > 0) {
                console.warn('Format filter checkboxes are checked but getFormatFilterValue returned empty. Pending value:', pendingFormatValue);
            }
        } catch(e) { 
            console.error('Error getting format filter value:', e);
            activeFilters.category = ''; 
        }
        try { activeFilters.volume = getMultiselectValueAndClearPending('vol-filter'); } catch(e) { activeFilters.volume = ''; }
        try { activeFilters.profile = getMultiselectValueAndClearPending('profile-filter'); } catch(e) { activeFilters.profile = ''; }
        try { activeFilters.el = getMultiselectValueAndClearPending('el-filter'); } catch(e) { activeFilters.el = ''; }
        try { activeFilters.container = getMultiselectValueAndClearPending('container-filter'); } catch(e) { activeFilters.container = ''; }
        activeFilters.is_hybrid = document.getElementById('hybrid-filter-header') ? document.getElementById('hybrid-filter-header').value : '';
        try { activeFilters.secondary_hdr = getMultiselectValueAndClearPending('secondary-filter'); } catch(e) { activeFilters.secondary_hdr = ''; }
        activeFilters.status = document.getElementById('status-filter-header') ? document.getElementById('status-filter-header').value : '';
        try { activeFilters.resolution = getMultiselectValueAndClearPending('res-filter'); } catch(e) { activeFilters.resolution = ''; }
        try { activeFilters.video_source = getMultiselectValueAndClearPending('video-source-filter'); } catch(e) { activeFilters.video_source = ''; }
        try { activeFilters.source_format = getMultiselectValueAndClearPending('source-format-filter'); } catch(e) { activeFilters.source_format = ''; }
        try { activeFilters.video_codec = getMultiselectValueAndClearPending('video-codec-filter'); } catch(e) { activeFilters.video_codec = ''; }
        activeFilters.is_3d = document.getElementById('is-3d-filter-header') ? document.getElementById('is-3d-filter-header').value : '';
        try { activeFilters.edition = getMultiselectValueAndClearPending('edition-filter'); } catch(e) { activeFilters.edition = ''; }
        try { activeFilters.media_type = getMultiselectValueAndClearPending('media-type-filter'); } catch(e) { activeFilters.media_type = ''; }
        const sizeFilter = document.getElementById('size-filter-header') ? document.getElementById('size-filter-header').value : '';
        const sizeParsed = parseFilterValue(sizeFilter);
        activeFilters.size_op = sizeParsed.op;
        activeFilters.size_val = sizeParsed.value;
        
        const bitFilter = document.getElementById('bit-filter-header') ? document.getElementById('bit-filter-header').value : '';
        const bitParsed = parseFilterValue(bitFilter);
        activeFilters.bit_op = bitParsed.op;
        activeFilters.bit_val = bitParsed.value;
        
        try { activeFilters.audio = getMultiselectValueAndClearPending('audio-filter'); } catch(e) { activeFilters.audio = ''; }

        const perPageVal = document.getElementById('per-page-select') ? document.getElementById('per-page-select').value : '100';
        const tbody = document.getElementById('video-table-body');
        tbody.innerHTML = '<tr><td colspan="33" style="text-align:center; padding: 20px;">Loading...</td></tr>';

        try {
            const params = new URLSearchParams({ page: currentPage, per_page: perPageVal, sort: sortCol, order: sortOrder, ...activeFilters });
            const res = await fetch(`/api/videos?${params}`);
            if (!res.ok) throw new Error(`Server Error: ${res.status}`);
            const data = await res.json();
            if (!data || !data.rows) {
                throw new Error("Invalid API response: missing data or rows");
            }
            
            lastStats = data.stats; 
            lastStatsFiltered = data.stats_filtered;
            currentRows = []; 
            applyStatsToUI(data.stats, data.total_items);

            updateCharts(data.stats, data.stats_filtered, data.filter_options); 
            updateFilterDropdowns(data.filter_options);
            
            // NEVER recalculate on data load - only use saved widths or calculate on first load
            // Saved widths are applied via updateSettingsUI -> applyColumnWidths
            updateSettingsUI();
            updateExportButtonText(); // Initialize export button text
            loadFilterPresetsList(); // Load filter presets list
            
            // Update sort icon display
            document.querySelectorAll('.sort-icon').forEach(e => e.innerText = '');
            const arrow = sortOrder === 'asc' ? '▲' : '▼';
            const icon = document.getElementById('sort-' + sortCol);
            if(icon) icon.innerText = arrow;

            if (data.rows.length === 0) {
                tbody.innerHTML = '<tr><td colspan="33" style="text-align:center; padding: 20px;">No results found</td></tr>';
            } else {
                currentRowData = [];
                currentRowDataEncoded = [];
                tbody.innerHTML = data.rows.map((row, rowIndex) => {
                    const rowData = {
                        filename: row[0], category: row[1], profile: row[2], el_type: row[3],
                        container: row[4], source_vol: row[5], full_path: row[6], last_scanned: row[7],
                        resolution: row[8], bitrate: row[9], scan_error: row[10], is_hybrid: row[11],
                        secondary_hdr: row[12], width: row[13], height: row[14], file_size: row[15],
                        bl_id: row[16], audio_codecs: row[17], subtitles: row[18], max_cll: row[19], max_fall: row[20],
                        video_source: row[21], source_format: row[22], video_codec: row[23], is_3d: row[24], edition: row[25], year: row[26],
                        media_type: row[27], show_title: row[28], season: row[29], episode: row[30], movie_title: row[31], episode_title: row[32]
                    };
                    const rowJson = encodeURIComponent(JSON.stringify(rowData));
                    currentRowData.push(rowData);
                    currentRowDataEncoded.push(rowJson);
                    
                    currentRows.push(row[6]); 
                    const hasError = row[10]; 
                    const isHybrid = row[11] === 1;
                    const secHdr = row[12];
                    const resText = row[8] || '-';
                    const vidW = row[13] || 0;
                    const vidH = row[14] || 0;
                    const vidSize = row[15] || 0;
                    const dateDisplay = row[7] ? row[7].split(' ')[0] : '--';
                    const audioTxt = row[17] || '-';
                    const subTxt = row[18] ? row[18].substring(0, 10) + (row[18].length>10?'...':'') : '-';
                    const cllTxt = row[19] ? row[19] : '-';
                    const fallTxt = row[20] ? row[20] : '-';

                    let mainBadge = '', secBadge = '-', hybridHtml = '<span style="opacity:0.3">-</span>';
                    let statusText = `<span class="badge badge-ok" onclick="setFilter('status', 'ok')">OK</span>`;
                    
                    if (hasError) {
                        const safeError = (hasError || '').replace(/"/g, '&quot;');
                        statusText = `<span class="badge badge-fail" title="${safeError}" style="cursor: help;" onclick="setFilter('status', 'failed')">FAILED ⓘ</span>`;
                        mainBadge = '<span style="color:#888">-</span>';
                    } else {
                        let clickFn = '';
                        if (row[1] === 'dovi') {
                            let cls = 'badge-dovi', txt = 'DOVI';
                            if (row[2] == '7') { 
                                if (row[3] === 'FEL') { cls = 'badge-p7-fel'; txt = 'DV P7 FEL'; clickFn = `filterBadge('dovi', '7', 'FEL')`; }
                                else if (row[3] === 'MEL') { cls = 'badge-p7-mel'; txt = 'DV P7 MEL'; clickFn = `filterBadge('dovi', '7', 'MEL')`; }
                                else { cls = 'badge-p7'; txt = 'DV P7'; clickFn = `filterBadge('dovi', '7')`; }
                            } 
                            else if (row[2] == '5') { cls = 'badge-p5'; txt = 'DV P5'; clickFn = `filterBadge('dovi', '5')`; }
                            else if (row[2] == '8.1') { cls = 'badge-p8'; txt = 'DV P8.1'; clickFn = `filterBadge('dovi', '8.1')`; }
                            else if (row[2] == '8.4') { cls = 'badge-p84'; txt = 'DV P8.4'; clickFn = `filterBadge('dovi', '8.4')`; }
                            else if (row[2] == '8') { cls = 'badge-p8'; txt = 'DV P8'; clickFn = `filterBadge('dovi', '8')`; }
                            else { clickFn = `filterBadge('dovi')`; }
                            mainBadge = `<span class="badge ${cls}" onclick="${clickFn}" title="Filter: ${txt}" style="cursor:pointer">${txt}</span>`;
                        } else {
                            let cls = `badge-${row[1]}`, txt = (row[1] || '').toUpperCase().replace('_ONLY', '');
                            if (row[1] === 'hdr10plus') txt = 'HDR10Plus';
                            clickFn = `filterBadge('${row[1] || ''}')`;
                            mainBadge = `<span class="badge ${cls}" onclick="${clickFn}" title="Filter: ${txt}" style="cursor:pointer">${txt}</span>`;
                        }
                        if (secHdr) {
                            let cls = `badge-${(secHdr || '').toLowerCase().replace('+', 'plus').replace(' ', '')}`;
                            let txt = (secHdr || '').replace('+', 'Plus'); 
                            const secClick = `filterBadge(null, null, null, '${(secHdr || '').replace(/'/g, "\\'")}')`;
                            secBadge = `<span class="badge ${cls}" onclick="${secClick}" title="Filter Secondary: ${txt}" style="cursor:pointer">${txt}</span>`;
                        }
                        if (isHybrid) hybridHtml = `<span style="color:#ffb6c1; font-weight:bold;">YES</span>`;
                    }

                    const isChecked = selectedPaths.has(row[6]) ? 'checked' : '';
                    const safePath = (row[6] || '').replace(/'/g, "\\'");
                    const resIconHtml = resText !== '-' ? `<div class="res-icon-wrapper" style="display:inline-block;" onclick="setFilter('resolution', '${resText.replace(/'/g, "\\'")}')"><img src="/static/${resText.toLowerCase()}.png" alt="${resText}" style="height:28px; vertical-align:middle;" onerror="this.outerHTML='<span>'+this.alt+'</span>'"></div>` : '-';

                    return `<tr data-row-index="${rowIndex}" onclick="handleRowClick(event, ${rowIndex}, '${safePath}')" oncontextmenu="openRowContextMenu(event, ${rowIndex}, '${safePath}')">
                            <td class="col-chk"><input type="checkbox" class="row-chk" ${isChecked} onclick="event.stopPropagation(); toggleRow(this, '${safePath}')"></td>
                            <td title="${(row[6] || '').replace(/"/g, '&quot;')}" class="col-file">
                                <div class="file-name" style="cursor:pointer; color:#fff;" onclick="event.stopPropagation(); showDetails('${rowJson}')">${(row[0] || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
                                <div class="file-path">${(row[6] || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
                            </td>
                            <td class="td-center col-hyb">${hybridHtml}</td>
                            <td class="td-center col-main">${mainBadge}</td>
                            <td class="td-center col-prof">${row[2] ? 'P'+row[2] : '-'}</td>
                            <td class="td-center col-el hide-col-el">${row[3] || '-'}</td>
                            <td class="td-center col-sec">${secBadge}</td>
                            <td class="td-center col-res">${resIconHtml}</td>
                            <td class="td-center col-width" style="font-family:monospace; font-size:0.8em; color:#aaa;">${vidW || '-'}</td>
                            <td class="td-center col-height" style="font-family:monospace; font-size:0.8em; color:#aaa;">${vidH || '-'}</td>
                            <td class="col-size" style="font-family:monospace; color:#ccc;">${formatBytes(vidSize)}</td>
                            <td class="col-bit">${row[9] ? row[9] + ' Mbps' : 'N/A'}</td>
                            <td class="col-vol">${row[5] || ''}</td>
                            <td class="td-center col-cont" style="font-family:monospace; font-size:0.85em; color:#aaa; text-transform:uppercase;">${row[4] || '-'}</td>
                            <td class="col-scan" style="opacity:0.4; font-size:0.8em">${dateDisplay}</td>
                            <td class="td-center col-stat">${statusText}</td>
                            <td class="col-audio hide-col-audio" title="${(audioTxt || '').replace(/"/g, '&quot;')}">${(audioTxt || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</td>
                            <td class="col-sub hide-col-sub" title="${(row[18] || '').replace(/"/g, '&quot;')}">${(subTxt || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</td>
                            <td class="col-cll hide-col-cll" title="MaxCLL / FALL">${cllTxt}</td>
                            <td class="col-fall hide-col-fall" title="MaxFALL">${fallTxt}</td>
                            <td class="td-center col-video-source hide-col-video-source">${row[21] || '-'}</td>
                            <td class="td-center col-source-format hide-col-source-format">${row[22] || '-'}</td>
                            <td class="td-center col-video-codec hide-col-video-codec">${row[23] || '-'}</td>
                            <td class="td-center col-is-3d hide-col-is-3d">${row[24] === 1 ? 'YES' : '-'}</td>
                            <td class="col-edition hide-col-edition">${row[25] || '-'}</td>
                            <td class="td-center col-year hide-col-year">${row[26] || '-'}</td>
                            <td class="td-center col-media-type hide-col-media-type">${row[27] ? row[27].toString().toUpperCase() : '-'}</td>
                            <td class="col-show-title hide-col-show-title" title="${(row[28] || '').replace(/"/g, '&quot;')}">${(row[28] || '').replace(/</g, '&lt;').replace(/>/g, '&gt;') || '-'}</td>
                            <td class="td-center col-season hide-col-season">${row[29] ?? '-'}</td>
                            <td class="td-center col-episode hide-col-episode">${row[30] ?? '-'}</td>
                            <td class="col-movie-title hide-col-movie-title" title="${(row[31] || '').replace(/"/g, '&quot;')}">${(row[31] || '').replace(/</g, '&lt;').replace(/>/g, '&gt;') || '-'}</td>
                            <td class="col-episode-title hide-col-episode-title" title="${(row[32] || '').replace(/"/g, '&quot;')}">${(row[32] || '').replace(/</g, '&lt;').replace(/>/g, '&gt;') || '-'}</td>
                            <td class="col-del"><button class="trash-btn" onclick="event.stopPropagation(); promptDelete('${safePath}')">🗑</button></td>
                        </tr>`;
                }).join('');
            }
            if (savedColumnOrder) {
                applyColumnOrder(savedColumnOrder);
            }
            initColumnDrag();
            initHeaderScrollbar();
            syncHeaderScrollbar();

            totalPages = data.total_pages;
            document.getElementById('page-jump').value = data.page;
            document.getElementById('pageTotalDisplay').innerText = totalPages;
            document.getElementById('res-filtered').innerText = data.total_items;
            document.getElementById('res-total-display').innerText = data.stats.total;
            document.getElementById('master-chk').style.visibility = data.rows.length > 0 ? 'visible' : 'hidden';
            updateDeleteBtn();
            
            // Don't re-apply visible columns here; it forces a width recalculation
            // and overrides saved column widths on reload.
            if (selectedRowIndex >= data.rows.length) {
                selectedRowIndex = data.rows.length - 1;
            }
            updateSelectedRowHighlight();

        } catch (e) {
            console.error(e);
            const tbody = document.getElementById('video-table-body');
            if (tbody) {
                tbody.innerHTML = `<tr><td colspan="33" style="text-align:center; padding: 20px; color:#e74c3c; font-weight:bold;">Error Loading Data: ${e.message}</td></tr>`;
            }
        } finally {
            isLoading = false;
        }
    }

    window.addEventListener('keydown', (e) => {
        if (isTypingTarget(e.target)) return;
        const key = e.key;
        if (key === 'j' || key === 'ArrowDown') {
            e.preventDefault();
            moveRowSelection(1);
            return;
        }
        if (key === 'k' || key === 'ArrowUp') {
            e.preventDefault();
            moveRowSelection(-1);
            return;
        }
        if (key === 'Enter') {
            if (selectedRowIndex >= 0 && currentRowDataEncoded[selectedRowIndex]) {
                e.preventDefault();
                showDetails(currentRowDataEncoded[selectedRowIndex]);
            }
            return;
        }
        if (key === 'r' || key === 'R') {
            if (selectedRowIndex >= 0 && currentRowData[selectedRowIndex]) {
                e.preventDefault();
                rescanSelectedFile();
            }
            return;
        }
    });

    document.addEventListener('click', (e) => {
        const suggestionsEl = document.getElementById('search-suggestions');
        if (!suggestionsEl) return;
        if (!e.target.closest('.search-wrap')) {
            suggestionsEl.style.display = 'none';
        }
    });

    document.addEventListener('click', (e) => {
        if (!e.target.closest('#row-context-menu')) {
            closeContextMenu();
        }
    });

    document.addEventListener('input', (e) => {
        if (e.target && e.target.id === 'search-bar') {
            updateSearchSuggestions();
        }
    });

    document.addEventListener('click', (e) => {
        const target = e.target;
        if (target && target.classList && target.classList.contains('search-suggestion')) {
            const value = target.getAttribute('data-value');
            if (value) {
                applySearchSuggestion(value);
            }
        }
    });

    // --- NEW DETAILS MODAL LOGIC ---
    function showDetails(rowDataStr) {
        try {
            const data = JSON.parse(decodeURIComponent(rowDataStr));
            document.getElementById('det-path').innerText = data.full_path;
            currentDetailsPath = data.full_path || '';
            const mediaTypeEl = document.getElementById('det-media-type');
            if (mediaTypeEl) {
                mediaTypeEl.value = data.media_type || '';
                currentDetailsMediaType = mediaTypeEl.value;
                updateDetailsTypeVisibility(mediaTypeEl.value);
                mediaTypeEl.onchange = () => updateDetailsTypeVisibility(mediaTypeEl.value);
            }
            const showTitleEl = document.getElementById('det-show-title');
            const episodeTitleEl = document.getElementById('det-episode-title');
            const movieTitleEl = document.getElementById('det-movie-title');
            const seasonEl = document.getElementById('det-season');
            const episodeEl = document.getElementById('det-episode');
            const yearEl = document.getElementById('det-year');
            const videoSourceEl = document.getElementById('det-video-source');
            const sourceFormatEl = document.getElementById('det-source-format');
            const mainHdrEl = document.getElementById('det-main-hdr');
            const secondaryHdrEl = document.getElementById('det-secondary-hdr');
            if (showTitleEl) showTitleEl.value = data.show_title || '';
            if (episodeTitleEl) episodeTitleEl.value = data.episode_title || '';
            if (movieTitleEl) movieTitleEl.value = data.movie_title || '';
            if (seasonEl) seasonEl.value = data.season ?? '';
            if (episodeEl) episodeEl.value = data.episode ?? '';
            if (yearEl) yearEl.value = data.year ?? '';
            if (videoSourceEl) videoSourceEl.value = data.video_source || '';
            if (sourceFormatEl) sourceFormatEl.value = data.source_format || '';
            if (mainHdrEl) mainHdrEl.value = data.category || '';
            if (secondaryHdrEl) secondaryHdrEl.value = data.secondary_hdr || '';
            currentDetailsMeta = {
                show_title: data.show_title || '',
                episode_title: data.episode_title || '',
                movie_title: data.movie_title || '',
                season: data.season ?? '',
                episode: data.episode ?? '',
                year: data.year ?? '',
                video_source: data.video_source || '',
                source_format: data.source_format || '',
                category: data.category || '',
                secondary_hdr: data.secondary_hdr || ''
            };
            const viewData = { ...data };
            delete viewData.full_path; 
            document.getElementById('det-json').innerText = JSON.stringify(viewData, null, 2);
            document.getElementById('details-modal').style.display = 'block';
        } catch(e) { console.error("Error showing details", e); }
    }
    function updateDetailsTypeVisibility(typeValue) {
        const showTitleRow = document.getElementById('det-show-title-row');
        const episodeTitleRow = document.getElementById('det-episode-title-row');
        const seasonEpisodeRow = document.getElementById('det-season-episode-row');
        const movieTitleRow = document.getElementById('det-movie-title-row');
        if (typeValue === 'movie') {
            if (showTitleRow) showTitleRow.style.display = 'none';
            if (episodeTitleRow) episodeTitleRow.style.display = 'none';
            if (seasonEpisodeRow) seasonEpisodeRow.style.display = 'none';
            if (movieTitleRow) movieTitleRow.style.display = '';
        } else if (typeValue === 'tv') {
            if (showTitleRow) showTitleRow.style.display = '';
            if (episodeTitleRow) episodeTitleRow.style.display = '';
            if (seasonEpisodeRow) seasonEpisodeRow.style.display = '';
            if (movieTitleRow) movieTitleRow.style.display = 'none';
        } else {
            if (showTitleRow) showTitleRow.style.display = '';
            if (episodeTitleRow) episodeTitleRow.style.display = '';
            if (seasonEpisodeRow) seasonEpisodeRow.style.display = '';
            if (movieTitleRow) movieTitleRow.style.display = '';
        }
    }
    async function saveDetailsMediaType() {
        const mediaTypeEl = document.getElementById('det-media-type');
        if (!mediaTypeEl || !currentDetailsPath) return;
        const newValue = mediaTypeEl.value || '';
        if (newValue === currentDetailsMediaType) return;
        try {
            const res = await fetch('/api/update_media_type', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ full_path: currentDetailsPath, media_type: newValue })
            });
            if (!res.ok) throw new Error(`Server Error: ${res.status}`);
            showToast('Type updated');
            currentDetailsMediaType = newValue;
            loadData();
        } catch (e) {
            console.error('Failed to update media type:', e);
            showToast('Failed to update type');
        }
    }
    async function saveDetailsMetadata() {
        if (!currentDetailsPath) return;
        const showTitleEl = document.getElementById('det-show-title');
        const episodeTitleEl = document.getElementById('det-episode-title');
        const movieTitleEl = document.getElementById('det-movie-title');
        const seasonEl = document.getElementById('det-season');
        const episodeEl = document.getElementById('det-episode');
        const yearEl = document.getElementById('det-year');
        const videoSourceEl = document.getElementById('det-video-source');
        const sourceFormatEl = document.getElementById('det-source-format');
        const mainHdrEl = document.getElementById('det-main-hdr');
        const secondaryHdrEl = document.getElementById('det-secondary-hdr');
        const payload = {
            full_path: currentDetailsPath,
            show_title: showTitleEl ? showTitleEl.value.trim() : '',
            episode_title: episodeTitleEl ? episodeTitleEl.value.trim() : '',
            movie_title: movieTitleEl ? movieTitleEl.value.trim() : '',
            season: seasonEl && seasonEl.value !== '' ? parseInt(seasonEl.value, 10) : null,
            episode: episodeEl && episodeEl.value !== '' ? parseInt(episodeEl.value, 10) : null,
            year: yearEl && yearEl.value !== '' ? parseInt(yearEl.value, 10) : null,
            video_source: videoSourceEl ? videoSourceEl.value.trim() : '',
            source_format: sourceFormatEl ? sourceFormatEl.value.trim() : '',
            category: mainHdrEl ? mainHdrEl.value.trim() : '',
            secondary_hdr: secondaryHdrEl ? secondaryHdrEl.value.trim() : ''
        };
        const changed = Object.keys(currentDetailsMeta).some(key => {
            return (currentDetailsMeta[key] ?? '') !== (payload[key] ?? '');
        });
        if (!changed) return;
        try {
            const res = await fetch('/api/update_metadata', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!res.ok) throw new Error(`Server Error: ${res.status}`);
            showToast('Details updated');
            currentDetailsMeta = {
                show_title: payload.show_title || '',
                episode_title: payload.episode_title || '',
                movie_title: payload.movie_title || '',
                season: payload.season ?? '',
                episode: payload.episode ?? '',
                year: payload.year ?? '',
                video_source: payload.video_source || '',
                source_format: payload.source_format || '',
                category: payload.category || '',
                secondary_hdr: payload.secondary_hdr || ''
            };
            loadData();
        } catch (e) {
            console.error('Failed to update details:', e);
            showToast('Failed to update details');
        }
    }

    function openBulkEdit() {
        closeContextMenu();
        if (selectedPaths.size === 0) {
            showToast('Select rows to bulk edit');
            return;
        }
        const countEl = document.getElementById('bulk-edit-count');
        if (countEl) countEl.innerText = selectedPaths.size;
        const resetIds = [
            'bulk-media-type', 'bulk-show-title', 'bulk-episode-title', 'bulk-movie-title',
            'bulk-year', 'bulk-season', 'bulk-episode', 'bulk-video-source', 'bulk-source-format',
            'bulk-main-hdr', 'bulk-secondary-hdr'
        ];
        resetIds.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.value = '';
        });
        const clearIds = [
            'bulk-clear-media-type', 'bulk-clear-show-title', 'bulk-clear-episode-title',
            'bulk-clear-movie-title', 'bulk-clear-year', 'bulk-clear-season', 'bulk-clear-episode',
            'bulk-clear-video-source', 'bulk-clear-source-format', 'bulk-clear-main-hdr', 'bulk-clear-secondary-hdr'
        ];
        clearIds.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.checked = false;
        });
        const modal = document.getElementById('bulk-edit-modal');
        if (modal) modal.style.display = 'block';
    }

    function closeBulkEdit() {
        const modal = document.getElementById('bulk-edit-modal');
        if (modal) modal.style.display = 'none';
    }

    async function applyBulkEdit() {
        if (selectedPaths.size === 0) {
            showToast('Select rows to bulk edit');
            return;
        }
        const mediaTypeEl = document.getElementById('bulk-media-type');
        const clearMediaTypeEl = document.getElementById('bulk-clear-media-type');
        const showTitleEl = document.getElementById('bulk-show-title');
        const clearShowTitleEl = document.getElementById('bulk-clear-show-title');
        const episodeTitleEl = document.getElementById('bulk-episode-title');
        const clearEpisodeTitleEl = document.getElementById('bulk-clear-episode-title');
        const movieTitleEl = document.getElementById('bulk-movie-title');
        const clearMovieTitleEl = document.getElementById('bulk-clear-movie-title');
        const yearEl = document.getElementById('bulk-year');
        const clearYearEl = document.getElementById('bulk-clear-year');
        const seasonEl = document.getElementById('bulk-season');
        const clearSeasonEl = document.getElementById('bulk-clear-season');
        const episodeEl = document.getElementById('bulk-episode');
        const clearEpisodeEl = document.getElementById('bulk-clear-episode');
        const videoSourceEl = document.getElementById('bulk-video-source');
        const clearVideoSourceEl = document.getElementById('bulk-clear-video-source');
        const sourceFormatEl = document.getElementById('bulk-source-format');
        const clearSourceFormatEl = document.getElementById('bulk-clear-source-format');
        const mainHdrEl = document.getElementById('bulk-main-hdr');
        const clearMainHdrEl = document.getElementById('bulk-clear-main-hdr');
        const secondaryHdrEl = document.getElementById('bulk-secondary-hdr');
        const clearSecondaryHdrEl = document.getElementById('bulk-clear-secondary-hdr');

        const mediaType = mediaTypeEl ? mediaTypeEl.value.trim().toLowerCase() : '';
        const clearMediaType = clearMediaTypeEl ? clearMediaTypeEl.checked : false;
        const payload = {};
        const setIf = (key, value, clear) => {
            if (clear) {
                payload[key] = '';
                return;
            }
            if (value !== null && value !== undefined && value !== '') payload[key] = value;
        };
        setIf('show_title', showTitleEl ? showTitleEl.value.trim() : '', clearShowTitleEl ? clearShowTitleEl.checked : false);
        setIf('episode_title', episodeTitleEl ? episodeTitleEl.value.trim() : '', clearEpisodeTitleEl ? clearEpisodeTitleEl.checked : false);
        setIf('movie_title', movieTitleEl ? movieTitleEl.value.trim() : '', clearMovieTitleEl ? clearMovieTitleEl.checked : false);
        const clearYear = clearYearEl ? clearYearEl.checked : false;
        const yearVal = yearEl && yearEl.value !== '' ? parseInt(yearEl.value, 10) : null;
        if (clearYear) payload.year = null;
        else if (yearVal !== null && !Number.isNaN(yearVal)) payload.year = yearVal;
        const clearSeason = clearSeasonEl ? clearSeasonEl.checked : false;
        const seasonVal = seasonEl && seasonEl.value !== '' ? parseInt(seasonEl.value, 10) : null;
        if (clearSeason) payload.season = null;
        else if (seasonVal !== null && !Number.isNaN(seasonVal)) payload.season = seasonVal;
        const clearEpisode = clearEpisodeEl ? clearEpisodeEl.checked : false;
        const episodeVal = episodeEl && episodeEl.value !== '' ? parseInt(episodeEl.value, 10) : null;
        if (clearEpisode) payload.episode = null;
        else if (episodeVal !== null && !Number.isNaN(episodeVal)) payload.episode = episodeVal;
        setIf('video_source', videoSourceEl ? videoSourceEl.value.trim() : '', clearVideoSourceEl ? clearVideoSourceEl.checked : false);
        setIf('source_format', sourceFormatEl ? sourceFormatEl.value.trim() : '', clearSourceFormatEl ? clearSourceFormatEl.checked : false);
        setIf('category', mainHdrEl ? mainHdrEl.value.trim() : '', clearMainHdrEl ? clearMainHdrEl.checked : false);
        setIf('secondary_hdr', secondaryHdrEl ? secondaryHdrEl.value.trim() : '', clearSecondaryHdrEl ? clearSecondaryHdrEl.checked : false);

        const hasMetadata = Object.keys(payload).length > 0;
        const hasType = clearMediaType || mediaType === 'movie' || mediaType === 'tv';
        if (!hasMetadata && !hasType) {
            showToast('No fields set');
            return;
        }

        const paths = Array.from(selectedPaths);
        let failed = 0;
        for (const fullPath of paths) {
            try {
                if (hasType) {
                    const resType = await fetch('/api/update_media_type', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ full_path: fullPath, media_type: clearMediaType ? '' : mediaType })
                    });
                    if (!resType.ok) throw new Error(`Type update failed: ${resType.status}`);
                }
                if (hasMetadata) {
                    const resMeta = await fetch('/api/update_metadata', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ full_path: fullPath, ...payload })
                    });
                    if (!resMeta.ok) throw new Error(`Metadata update failed: ${resMeta.status}`);
                }
            } catch (e) {
                console.error('Bulk edit failed for', fullPath, e);
                failed += 1;
            }
        }

        closeBulkEdit();
        loadData();
        if (failed > 0) {
            showToast(`Bulk edit completed with ${failed} failures`);
        } else {
            showToast('Bulk edit applied');
        }
    }

    async function bulkRescanSelected() {
        if (selectedPaths.size === 0) {
            showToast('Select rows to rescan');
            return;
        }
        const paths = Array.from(selectedPaths);
        let failed = 0;
        showToast(`Rescanning ${paths.length} file(s)...`);
        for (const fullPath of paths) {
            try {
                const res = await fetch('/api/rescan_file', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ full_path: fullPath })
                });
                const data = await res.json();
                if (!res.ok || data.status !== 'ok') {
                    throw new Error(data.message || 'Rescan failed');
                }
            } catch (e) {
                console.error('Bulk rescan failed for', fullPath, e);
                failed += 1;
            }
        }
        closeBulkEdit();
        loadData();
        if (failed > 0) {
            showToast(`Rescan completed with ${failed} failures`);
        } else {
            showToast('Rescan completed');
        }
    }

    async function openFoldersModal() {
        await loadFolderVolumes();
        renderScanFolders();
        const modal = document.getElementById('folders-modal');
        if (modal) modal.style.display = 'block';
    }

    function closeFoldersModal() {
        const modal = document.getElementById('folders-modal');
        if (modal) modal.style.display = 'none';
    }

    async function loadFolderVolumes() {
        try {
            const res = await fetch('/api/pre_scan_check');
            const data = await res.json();
            folderVolumes = (data || []).filter(v => v.status === 'online');
            const select = document.getElementById('folders-volume-select');
            if (select) {
                select.innerHTML = folderVolumes.map(v => `<option value="${v.name}">${v.name}</option>`).join('');
                if (!folderBrowser.volume && folderVolumes.length > 0) {
                    folderBrowser.volume = folderVolumes[0].name;
                    folderBrowser.path = '';
                }
                if (folderBrowser.volume) select.value = folderBrowser.volume;
            }
            await browseFolders(folderBrowser.path || '');
        } catch (e) {
            console.error('Failed to load volumes', e);
            showToast('Failed to load volumes');
        }
    }

    async function onFoldersVolumeChange() {
        const select = document.getElementById('folders-volume-select');
        if (!select) return;
        folderBrowser.volume = select.value;
        folderBrowser.path = '';
        await browseFolders('');
    }

    async function browseFolders(path) {
        if (!folderBrowser.volume) return;
        try {
            const params = new URLSearchParams({ volume: folderBrowser.volume, path: path || '' });
            const res = await fetch(`/api/browse?${params}`);
            const data = await res.json();
            if (!res.ok || data.status !== 'ok') throw new Error(data.message || 'Browse failed');
            folderBrowser.path = data.path || '';
            const pathEl = document.getElementById('folders-current-path');
            if (pathEl) pathEl.innerText = '/' + (folderBrowser.path || '');
            const listEl = document.getElementById('folders-dir-list');
            if (listEl) {
                if (!data.dirs || data.dirs.length === 0) {
                    listEl.innerHTML = '<div style="color:#666; font-size:0.85em;">No subfolders</div>';
                } else {
                    listEl.innerHTML = data.dirs.map(d => {
                        const nextPath = (folderBrowser.path ? folderBrowser.path + '/' : '') + d;
                        const encoded = encodeURIComponent(nextPath);
                        return `<div class="folder-row">
                            <div class="folder-path" style="cursor:pointer;" onclick="browseFoldersEncoded('${encoded}')">${d}</div>
                            <div class="folder-actions">
                                <button class="btn-grey folder-item-btn" onclick="browseFoldersEncoded('${encoded}')">Open</button>
                            </div>
                        </div>`;
                    }).join('');
                }
            }
        } catch (e) {
            console.error('Browse failed', e);
            showToast('Browse failed');
        }
    }

    function browseFoldersEncoded(encodedPath) {
        try {
            browseFolders(decodeURIComponent(encodedPath));
        } catch (e) {
            console.error('Invalid folder path', e);
        }
    }

    function browseFolderUp() {
        if (!folderBrowser.path) return;
        const parts = folderBrowser.path.split('/').filter(Boolean);
        parts.pop();
        browseFolders(parts.join('/'));
    }

    function addCurrentFolder() {
        if (!folderBrowser.volume) return;
        const path = folderBrowser.path || '';
        const exists = scanFolders.some(f => f.volume === folderBrowser.volume && (f.path || '') === path);
        if (!exists) {
            scanFolders.push({ volume: folderBrowser.volume, path: path, muted: false, type: 'auto' });
            renderScanFolders();
        }
    }

    function setFolderType(index, type) {
        if (!scanFolders[index]) return;
        scanFolders[index].type = type || 'auto';
    }

    function toggleFolderMute(index) {
        if (!scanFolders[index]) return;
        scanFolders[index].muted = !scanFolders[index].muted;
        renderScanFolders();
    }

    function removeScanFolder(index) {
        scanFolders.splice(index, 1);
        renderScanFolders();
    }

    function renderScanFolders() {
        const list = document.getElementById('folders-scan-list');
        if (!list) return;
        if (!scanFolders.length) {
            list.innerHTML = '<div style="color:#666; font-size:0.85em;">No folders added</div>';
            return;
        }
        list.innerHTML = scanFolders.map((f, idx) => {
            const pathText = `${f.volume}:${f.path ? '/' + f.path : '/'}`;
            const muted = !!f.muted;
            const type = f.type || 'auto';
            return `<div class="folder-row ${muted ? 'muted' : ''}">
                <select class="folder-type-select" onchange="setFolderType(${idx}, this.value)">
                    <option value="auto" ${type === 'auto' ? 'selected' : ''}>Auto</option>
                    <option value="tv" ${type === 'tv' ? 'selected' : ''}>TV</option>
                    <option value="movie" ${type === 'movie' ? 'selected' : ''}>Movie</option>
                </select>
                <div class="folder-path">${pathText}</div>
                <div class="folder-actions">
                    <button class="btn-grey folder-item-btn" onclick="toggleFolderMute(${idx})">${muted ? 'Scan' : 'Ignore'}</button>
                    <button class="btn-orange folder-item-btn folder-remove-btn" onclick="removeScanFolder(${idx})">-</button>
                </div>
            </div>`;
        }).join('');
    }

    async function saveScanFolders() {
        try {
            const res = await fetch('/api/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ scan_folders: JSON.stringify(scanFolders) })
            });
            if (!res.ok) throw new Error(`Server Error: ${res.status}`);
            showToast('Scan folders saved');
            closeFoldersModal();
        } catch (e) {
            console.error('Failed to save scan folders', e);
            showToast('Failed to save scan folders');
        }
    }
    async function closeDetails() { 
        await saveDetailsMediaType();
        await saveDetailsMetadata();
        document.getElementById('details-modal').style.display = 'none'; 
        currentDetailsPath = '';
        currentDetailsMediaType = '';
        currentDetailsMeta = {};
    }

    async function rescanFile(fullPath) {
        if (!fullPath) {
            showToast("No file selected");
            return;
        }
        try {
            showToast("Rescanning...");
            const res = await fetch('/api/rescan_file', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ full_path: fullPath })
            });
            const data = await res.json();
            if (!res.ok || data.status !== 'ok') {
                throw new Error(data.message || 'Rescan failed');
            }
            showToast("File rescanned");
            closeDetails();
            loadData();
        } catch (e) {
            showToast("Rescan failed");
            console.error("Rescan failed:", e);
        }
    }

    function rescanFileFromModal() {
        rescanFile(currentDetailsPath);
    }

    function rescanSelectedFile() {
        if (selectedRowIndex < 0 || !currentRowData[selectedRowIndex]) {
            showToast("No file selected");
            return;
        }
        rescanFile(currentRowData[selectedRowIndex].full_path);
    }
    function copyDetails() {
        const txt = document.getElementById('det-json').innerText;
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(txt).then(() => {
                showToast("Copied to clipboard!");
            }).catch(err => {
                console.error('Failed to copy:', err);
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = txt;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    showToast("Copied to clipboard!");
                } catch (e) {
                    showToast("Failed to copy");
                }
                document.body.removeChild(textArea);
            });
        } else {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = txt;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                showToast("Copied to clipboard!");
            } catch (e) {
                showToast("Failed to copy");
            }
            document.body.removeChild(textArea);
        }
    }

    // --- TOAST LOGIC ---
    function showToast(msg) {
        const t = document.getElementById('toast-notif');
        t.innerText = msg;
        t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 3000);
    }

    // --- WARNING POPUP FOR MISSING VOLUMES ---
    async function startScan(mode = scanMode) {
        try {
            const res = await fetch('/api/pre_scan_check');
            const data = await res.json();
            
            const hasIssues = data.some(v => v.status !== 'online');
            if (!hasIssues) {
                const force = document.getElementById('chk-force').checked;
                triggerScan([], force, mode); 
                return;
            }

            const container = document.getElementById('vol-list-container');
            container.innerHTML = data.map(v => {
                const isOnline = v.status === 'online';
                const cls = isOnline ? 'status-online' : 'status-offline';
                return `
                    <label class="vol-item">
                        <div class="vol-status-dot ${cls}"></div>
                        <div class="vol-name">${v.name} (${v.status.toUpperCase()})</div>
                        <input type="checkbox" class="vol-chk" value="${v.name}" ${isOnline ? 'checked' : ''}>
                    </label>
                `;
            }).join('');
            
            document.getElementById('volume-modal').style.display = 'block';
        } catch(e) { console.error("Pre-scan check failed", e); alert("Error checking volumes."); }
    }

    async function confirmScan(fromModal = false, mode = scanMode) {
        const checkboxes = document.querySelectorAll('.vol-chk:checked');
        const selected = Array.from(checkboxes).map(c => c.value);
        if (fromModal && selected.length === 0) { alert("Please select at least one volume."); return; }
        
        // Modal overrides
        let force = document.getElementById('chk-force').checked;
        if(fromModal) {
            force = document.getElementById('chk-force-rescan').checked;
        }

        document.getElementById('volume-modal').style.display = 'none';
        triggerScan(selected, force, mode);
    }

    async function triggerScan(targets, force, mode = scanMode) {
        document.body.classList.add('scanning');
        document.getElementById('scan-info-box').innerHTML = `STARTING <div class="spinner"></div>`;
        const debug = document.getElementById('chk-debug').checked;
        // Initialize scanStartTime immediately to start timer right away
        scanStartTime = Date.now() / 1000;
        
        try { 
            await fetch('/start', { 
                method: 'POST', 
                headers: {'Content-Type': 'application/json'}, 
                body: JSON.stringify({ 
                    threads: document.getElementById('scan-threads').value,
                    targets: targets,
                    force_rescan: force,
                    debug_mode: debug,
                    scan_mode: mode,
                    scan_folder: scanFolderTarget
                }) 
            }); 
            setTimeout(poll, 500); 
        } catch (e) { 
            document.body.classList.remove('scanning'); 
            scanStartTime = 0;
            alert("Failed to start scan."); 
        }
    }

    async function abortScan() {
        if(confirm("Stop scan?")) {
            console.log("[DEBUG] Abort button clicked - sending abort request to server");
            // Update UI immediately, don't wait for server response
            const btn = document.getElementById('btn-abort');
            if(btn) { 
                btn.disabled = true; 
                btn.innerText = "Stopping..."; 
            }
            const scanInfoBox = document.getElementById('scan-info-box');
            if(scanInfoBox) {
                scanInfoBox.innerHTML = `STOPPING <div class="spinner"></div>`;
            }
            isAnalyzingFiles = false; // Clear flag on abort
            stopRefreshInterval(); // Stop refresh interval on abort
            
            try {
                const response = await fetch('/abort', { method: 'POST' });
                const data = await response.json();
                console.log(`[DEBUG] Abort request acknowledged by server:`, data);
                // Continue polling to see when abort completes
                setTimeout(poll, 1000);
            } catch (e) {
                console.error("[ERROR] Abort failed:", e);
                // Don't show alert, just log - UI is already updated
            }
        }
    }


    // Start/stop refresh interval timer for table updates during file analysis
    function startRefreshInterval() {
        // Always stop existing timer first to avoid duplicates
        if (refreshIntervalTimer) {
            clearInterval(refreshIntervalTimer);
            refreshIntervalTimer = null;
        }
        const intervalEl = document.getElementById('scan-refresh');
        const intervalSeconds = parseInt(intervalEl?.value || 60) * 1000;
        refreshIntervalTimer = setInterval(() => {
            // Only refresh if we're scanning, analyzing files (not directory scanning), and not clearing/loading
            // Double-check isAnalyzingFiles flag to prevent refresh during directory scanning
            if (document.body.classList.contains('scanning') && isAnalyzingFiles && !isClearingFilters && !isLoading) {
                loadData();
            }
        }, intervalSeconds);
    }
    
    function stopRefreshInterval() {
        if (refreshIntervalTimer) {
            clearInterval(refreshIntervalTimer);
            refreshIntervalTimer = null;
        }
    }

    async function poll() {
        try {
            const res = await fetch('/progress');
            const data = await res.json();
            if (data.status === 'scanning') {
                document.body.classList.add('scanning');
                // Sync scanStartTime with server only on first poll or if timer hasn't started yet
                if (!scanStartTime) {
                    if (data.start_time && data.start_time > 0) {
                        // Server provides Unix timestamp, convert to relative start time
                        const srvDur = parseInt(data.last_duration.replace('s','')) || 0;
                        const now = Date.now() / 1000;
                        scanStartTime = now - srvDur;
                    } else {
                        // Fallback: initialize from duration if start_time not available
                        const srvDur = parseInt(data.last_duration.replace('s','')) || 0;
                        scanStartTime = (Date.now() / 1000) - srvDur;
                    }
                }
                // Don't sync after initial setup - let the client-side timer run continuously
                let pct = data.total > 0 ? Math.round((data.current / data.total) * 100) : 0;
                document.getElementById('progress-bar').style.width = pct + '%';
                document.getElementById('progress-text').innerText = `${pct}% (${data.current}/${data.total})`;
                document.getElementById('scan-info-box').innerHTML = `${data.file} <div class="spinner"></div>`;
                
                // Start refresh interval only when analyzing files (total > 0), not during directory scanning
                if (data.total > 0) {
                    if (!isAnalyzingFiles) {
                        isAnalyzingFiles = true; // Transition into analysis phase
                        startRefreshInterval(); // Start refresh timer once
                    }
                } else {
                    if (isAnalyzingFiles) {
                        isAnalyzingFiles = false; // Transition out of analysis phase
                        stopRefreshInterval(); // Stop refresh timer during directory scanning
                    }
                }
                
                // Update ribbon counts frequently; update charts/filters less often
                if (data.total > 0) {
                    const now = Date.now();
                    const shouldUpdateCharts = !lastFilterUpdate || (now - lastFilterUpdate >= 30000);
                    // Fetch stats without affecting the timer
                        fetch(`/api/videos?${new URLSearchParams({ page: 1, per_page: 1, ...activeFilters })}`)
                            .then(r => r.json())
                            .then(d => {
                                if (d.stats) {
                                lastStats = d.stats;
                                lastStatsFiltered = d.stats_filtered;
                                    applyStatsToUI(d.stats, d.total_items);
                                }
                            if (shouldUpdateCharts && d.filter_options) {
                                lastFilterUpdate = now;
                                updateFilterDropdowns(d.filter_options);
                                updateCharts(d.stats, d.stats_filtered, d.filter_options);
                                }
                            })
                            .catch(e => console.error("Failed to update filter options:", e));
                }
                
                // Only refresh table data during scan, don't call loadData() which resets duration timer
                // Table will refresh when scan completes
                setTimeout(poll, 1000);
            } else { 
                // Stop refresh interval when scan is not active
                isAnalyzingFiles = false; // Clear flag when scan completes
                stopRefreshInterval();
                if (document.body.classList.contains('scanning')) {
                    document.body.classList.remove('scanning');
                    scanStartTime = 0; // Reset timer when scan completes
                    lastFilterUpdate = 0; // Reset filter update timer
                    document.getElementById('scan-info-box').innerText = "IDLE";
                    const btn = document.getElementById('btn-abort');
                    if(btn) { btn.disabled = false; btn.innerText = "Abort Scan"; }
                    loadData(); 
                    updateLogs(); // Update console log when scan completes
                    if (data.last_report && data.scan_completed) {
                        const style = document.getElementById('notif-style').value;
                        if (style === 'toast') {
                            showToast(`Scan Complete! New: ${data.last_report.new}`);
                            fetch('/clear_completed', { method: 'POST' });
                        } else {
                            document.getElementById('report-modal').style.display = 'block';
                            document.getElementById('rep-scanned').innerText = data.last_report.scanned;
                            document.getElementById('rep-new').innerText = data.last_report.new;
                            document.getElementById('rep-failed').innerText = data.last_report.failed;
                            document.getElementById('rep-time').innerText = formatDuration(data.last_report.duration);
                            const offlineBox = document.getElementById('rep-offline-box');
                            const offlineList = document.getElementById('rep-offline-list');
                            if (data.last_report.offline && data.last_report.offline.length > 0) { offlineBox.style.display = 'block'; offlineList.innerText = data.last_report.offline.join('\n'); } else { offlineBox.style.display = 'none'; }
                            fetch('/clear_completed', { method: 'POST' });
                        }
                    }
                }
            }
        } catch (e) { 
            console.error("Poll error:", e);
            // Continue polling even on error to handle temporary network issues
            setTimeout(poll, 1000);
        }
    }

    // --- DELETION ---
    function toggleMaster(chk) {
        masterState = (masterState + 1) % 3;
        const chkEl = document.getElementById('master-chk');
        chkEl.className = 'col-chk ' + (masterState === 1 ? 'master-dash' : masterState === 2 ? 'master-x' : '');
        chkEl.checked = false; // Always uncheck the checkbox element itself
        if (masterState === 0) { selectedPaths.clear(); document.querySelectorAll('.row-chk').forEach(c => c.checked = false); } 
        else if (masterState === 1) { currentRows.forEach(p => selectedPaths.add(p)); document.querySelectorAll('.row-chk').forEach(c => c.checked = true); }
        updateDeleteBtn();
    }

    function toggleRow(chk, path) {
        if (chk.checked) selectedPaths.add(path); else selectedPaths.delete(path);
        if (masterState === 2) { masterState = 0; document.getElementById('master-chk').className = 'col-chk'; }
        updateDeleteBtn();
    }

    function updateDeleteBtn() {
        const wrapper = document.getElementById('main-action-wrapper');
        const btn = document.getElementById('btn-delete-action');
        const bulkBtn = document.getElementById('btn-bulk-edit');
        
        btn.classList.remove('btn-orange');

        if (selectedPaths.size > 0 || masterState === 2) {
            wrapper.classList.add('selection-active');
            if (masterState === 2) {
                btn.style.backgroundColor = '#e74c3c'; 
                btn.innerText = `DELETE ALL FILTERED`;
            } else {
                btn.style.backgroundColor = '#e67e22'; 
                btn.innerText = `DELETE (${selectedPaths.size})`;
            }
        } else {
            wrapper.classList.remove('selection-active');
        }

        if (bulkBtn) {
            const filteredCount = parseInt(document.getElementById('res-filtered')?.innerText || '0', 10);
            if (selectedPaths.size > 0) {
                bulkBtn.disabled = false;
                bulkBtn.innerText = `Bulk Edit/Rescan Selected (${selectedPaths.size})`;
            } else {
                bulkBtn.disabled = false;
                bulkBtn.innerText = `Bulk Edit/Rescan Filtered (${filteredCount})`;
            }
            bulkBtn.style.display = '';
        }
    }

    function openCleanDbModal() {
        const modal = document.getElementById('clean-db-modal');
        if (modal) modal.style.display = 'block';
        updateCleanDbPreview();
    }

    async function updateCleanDbPreview() {
        const previewEl = document.getElementById('clean-db-preview');
        if (!previewEl) return;
        previewEl.innerText = 'Preview: Loading number of entries which will be removed. Please wait...';
        try {
            const res = await fetch('/api/cleanup_db_preview');
            const data = await res.json();
            if (!res.ok || data.status !== 'ok') throw new Error(data.message || 'Preview failed');
            const count = data.count ?? 0;
            previewEl.innerText = `Preview: ${count} entries will be removed.`;
        } catch (e) {
            console.error('Cleanup preview failed', e);
            previewEl.innerText = 'Preview: Unable to calculate entries to remove.';
        }
    }

    async function confirmCleanDb() {
        try {
            const res = await fetch('/api/cleanup_db', { method: 'POST' });
            const data = await res.json();
            if (!res.ok || data.status !== 'ok') {
                throw new Error(data.message || 'Cleanup failed');
            }
            showToast(`Cleaned ${data.deleted || 0} entries`);
            loadData();
        } catch (e) {
            console.error('Cleanup failed', e);
            showToast('Cleanup failed');
        } finally {
            const modal = document.getElementById('clean-db-modal');
            if (modal) modal.style.display = 'none';
        }
    }

    function promptDelete(singlePath=null) {
        if (singlePath) { selectedPaths.clear(); selectedPaths.add(singlePath); }
        let count = (masterState === 2) ? parseInt(document.getElementById('res-filtered').innerText) : selectedPaths.size;
        document.getElementById('del-count').innerText = count;
        document.getElementById('delete-modal').style.display = 'block';
    }

    async function confirmDelete() {
        const currentFilters = {
            search: document.getElementById('search-bar').value,
            category: getFormatFilterValue(),
            volume: getMultiselectValue('vol-filter'),
            profile: getMultiselectValue('profile-filter'),
            el: getMultiselectValue('el-filter'),
            container: getMultiselectValue('container-filter'),
            media_type: getMultiselectValue('media-type-filter'),
            is_hybrid: document.getElementById('hybrid-filter-header') ? document.getElementById('hybrid-filter-header').value : '',
            secondary_hdr: getMultiselectValue('secondary-filter'),
            status: document.getElementById('status-filter-header') ? document.getElementById('status-filter-header').value : '',
            resolution: getMultiselectValue('res-filter'),
            size_op: (() => {
                const val = document.getElementById('size-filter-header') ? document.getElementById('size-filter-header').value : '';
                const parsed = parseFilterValue(val);
                return parsed.op;
            })(),
            size_val: (() => {
                const val = document.getElementById('size-filter-header') ? document.getElementById('size-filter-header').value : '';
                const parsed = parseFilterValue(val);
                return parsed.value;
            })(),
            bit_op: (() => {
                const val = document.getElementById('bit-filter-header') ? document.getElementById('bit-filter-header').value : '';
                const parsed = parseFilterValue(val);
                return parsed.op;
            })(),
            bit_val: (() => {
                const val = document.getElementById('bit-filter-header') ? document.getElementById('bit-filter-header').value : '';
                const parsed = parseFilterValue(val);
                return parsed.value;
            })(),
            audio: document.getElementById('audio-filter-header') ? document.getElementById('audio-filter-header').value : '',
            sort: sortCol,
            order: sortOrder
        };

        const payload = {
            paths: Array.from(selectedPaths),
            delete_all_filter: (masterState === 2),
            filters: currentFilters
        };
        await fetch('/api/delete', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload) });
        document.getElementById('delete-modal').style.display = 'none';
        selectedPaths.clear(); masterState = 0; document.getElementById('master-chk').className = 'col-chk'; updateDeleteBtn(); loadData();
    }

    // --- LOGS & SETTINGS ---
    async function updateSettingsUI() {
        try {
            const res = await fetch('/api/settings');
            const data = await res.json();
            if(document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'SELECT') {
                document.getElementById('sched-mode').value = data.scan_mode || 'manual';
                if(data.scan_mode === 'daily') document.getElementById('sched-val-time').value = data.scan_value;
                if(data.scan_mode === 'interval') document.getElementById('sched-val-hours').value = data.scan_value;
                if(data.scan_mode === 'weekly') document.getElementById('sched-val-week').value = data.scan_value;
                if(data.scan_mode === 'monthly') document.getElementById('sched-val-day').value = data.scan_value;

                document.getElementById('skip-words').value = data.skip_words || '';
                document.getElementById('min-size').value = data.min_size_mb || '50';
                if (data.log_limit) document.getElementById('log-limit').value = data.log_limit;
                if (data.threads) document.getElementById('scan-threads').value = data.threads;
                if (data.refresh_interval) document.getElementById('scan-refresh').value = data.refresh_interval;
                if (data.notif_style) document.getElementById('notif-style').value = data.notif_style;
                if (data.batch_size) document.getElementById('batch-size').value = data.batch_size;
                if (data.rpu_fel_threshold) document.getElementById('rpu-threshold').value = data.rpu_fel_threshold;
                if (data.force_rescan !== undefined) {
                    const forceMain = document.getElementById('chk-force');
                    const forceModal = document.getElementById('chk-force-rescan');
                    const checked = data.force_rescan === 'true' || data.force_rescan === true;
                    if (forceMain) forceMain.checked = checked;
                    if (forceModal) forceModal.checked = checked;
                }
                if (data.visible_cols) applyVisibleCols(data.visible_cols, !!data.column_widths);
                if (data.column_order) {
                    try {
                        savedColumnOrder = JSON.parse(data.column_order);
                        applyColumnOrder(savedColumnOrder);
                    } catch (e) {
                        console.error('Failed to parse column order:', e);
                        savedColumnOrder = null;
                    }
                }
                if (data.column_widths) {
                    try {
                        const widths = JSON.parse(data.column_widths);
                        // applyColumnWidths will check if all visible columns have widths
                        // If not, it will recalculate automatically
                        applyColumnWidths(widths);
                    } catch (e) {
                        console.error('Failed to parse column widths:', e);
                        hasSavedWidths = false;
                    }
                } else if (!data.column_widths) {
                    // No saved widths - need to calculate on first load
                    hasSavedWidths = false;
                }
                if (data.sort_order && !sortInitialized) {
                    setSortOrder(data.sort_order);
                    sortInitialized = true;
                }
                if (data.scan_folders) {
                    try {
                        const parsed = JSON.parse(data.scan_folders);
                        scanFolders = Array.isArray(parsed) ? parsed : [];
                    } catch (e) {
                        scanFolders = [];
                    }
                }
                updateScanButtonLabel();
                
                // Always calculate after a delay to ensure all visible columns get widths
                // applyColumnWidths will skip if all columns have valid saved widths
                // BUT respect manual resize block - don't recalculate if user has manually set widths
                setTimeout(() => {
                    if (manualResizeBlocked) {
                        console.log('[COLUMN_WIDTHS] Skipping automatic calculation - manual resize is active');
                        return;
                    }
                    
                    if (!hasSavedWidths) {
                        console.log('[COLUMN_WIDTHS] No saved widths, calculating...');
                        calculateColumnWidths(true, false);
                    } else {
                        // Double-check: verify all visible columns actually have widths applied
                        const table = document.querySelector('table');
                        const tableWrap = document.querySelector('.table-wrap');
                        if (table && tableWrap) {
                            const visibleColumns = [];
                            const headers = table.querySelectorAll('thead th');
                            headers.forEach(th => {
                                const classes = Array.from(th.classList);
                                const colClass = classes.find(c => c.startsWith('col-') && c !== 'col-chk' && c !== 'col-del');
                                if (colClass) {
                                    const isHidden = tableWrap.classList.contains('hide-' + colClass);
                                    if (!isHidden) {
                                        visibleColumns.push(colClass);
                                    }
                                }
                            });
                            
                            // Check if all visible columns have widths
                            const allHaveWidths = visibleColumns.every(col => {
                                const cells = document.querySelectorAll(`th.${col}, td.${col}`);
                                if (cells.length === 0) return false;
                                const width = window.getComputedStyle(cells[0]).width;
                                return parseFloat(width) > 0;
                            });
                            
                            if (!allHaveWidths) {
                                console.log('[COLUMN_WIDTHS] Some columns missing widths, recalculating...');
                                hasSavedWidths = false;
                                calculateColumnWidths(true, false);
                            }
                        }
                    }
                }, 300);
                toggleSchedInput();
            }
        } catch (e) { console.error("Failed to load settings", e); }
    }

    async function triggerPulse(el) { el.classList.remove('pulse-success', 'pulse-error'); void el.offsetWidth; const success = await saveSettings(false); if (success) { el.classList.add('pulse-success'); } else { el.classList.add('pulse-error'); } setTimeout(() => { el.classList.remove('pulse-success', 'pulse-error'); }, 1000); }

    async function saveSettings(animateButton = true) {
        let val = "";
        const mode = document.getElementById('sched-mode').value;
        if (mode === 'daily') val = document.getElementById('sched-val-time').value;
        else if (mode === 'interval') val = document.getElementById('sched-val-hours').value;
        else if (mode === 'weekly') val = document.getElementById('sched-val-week').value;
        else if (mode === 'monthly') val = document.getElementById('sched-val-day').value;

        const payload = {
            mode: mode, value: val,
            skip_words: document.getElementById('skip-words').value,
            min_size_mb: document.getElementById('min-size').value,
            log_limit: document.getElementById('log-limit').value,
            threads: document.getElementById('scan-threads').value,
            refresh_interval: document.getElementById('scan-refresh').value,
            visible_cols: getVisibleCols(),
            column_widths: JSON.stringify(getColumnWidths()),
            sort_order: getSortOrder(),
            notif_style: document.getElementById('notif-style').value,
            batch_size: document.getElementById('batch-size').value,
            rpu_fel_threshold: document.getElementById('rpu-threshold').value,
            force_rescan: document.getElementById('chk-force')?.checked || false,
            column_order: JSON.stringify(getColumnOrder())
        };

        try {
            const res = await fetch('/api/settings', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload) });
            if (res.ok) {
                if (animateButton) animateSuccess('btn-save', 'Save Settings', 'Saved');
                showToast("Settings saved successfully!");
                updateLogs();
                return true;
            } else {
                throw new Error("Server returned " + res.status);
            }
        } catch (e) {
            console.error("Save failed:", e);
            if (animateButton) animateFailure('btn-save', 'Save Settings');
            setTimeout(updateLogs, 500);
            return false;
        }
    }

    async function updateLogs() {
        try {
            const res = await fetch('/api/logs');
            const logs = await res.json();
            const consoleElem = document.getElementById('debug-console');
            consoleElem.innerHTML = logs.map(l => {
                let cls = 'log-default'; 
                // Check for [SUCCESS] first (before error), since success messages might contain words like "Errors:" or "failed_count"
                if (/\[SUCCESS\]/i.test(l)) cls = 'log-success';
                else if (/\[ERROR\]|\[CRITICAL\]|error|fail|critical|abort/i.test(l)) cls = 'log-err'; 
                else if (/finished|complete|analyzed|found|started|success/i.test(l)) cls = 'log-success';
                return `<span class="${cls}">${l}</span>`;
            }).join('<br>');
            consoleElem.scrollTop = consoleElem.scrollHeight;
        } catch (e) {}
    }

    function updateExportButtonText() {
        const format = document.querySelector('input[name="export-format"]:checked')?.value || 'csv';
        const btn = document.getElementById('btn-export');
        if (btn) {
            btn.textContent = format === 'json' ? 'Export JSON' : 'Export CSV';
        }
    }
    
    function exportData() {
        const format = document.querySelector('input[name="export-format"]:checked')?.value || 'csv';
        showToast(format === 'json' ? 'Export started (JSON)' : 'Export started (CSV)');
        if (format === 'json') {
            exportJSON();
        } else {
            exportCSV();
        }
    }

    function exportCSV() { 
        // Collect current filter values (same as loadData does)
        const currentFilters = { ...activeFilters };
        currentFilters.search = document.getElementById('search-bar') ? document.getElementById('search-bar').value : '';
        try { 
            currentFilters.category = getFormatFilterValue();
        } catch(e) { 
            currentFilters.category = ''; 
        }
        try { currentFilters.volume = getMultiselectValue('vol-filter'); } catch(e) { currentFilters.volume = ''; }
        try { currentFilters.profile = getMultiselectValue('profile-filter'); } catch(e) { currentFilters.profile = ''; }
        try { currentFilters.el = getMultiselectValue('el-filter'); } catch(e) { currentFilters.el = ''; }
        try { currentFilters.container = getMultiselectValue('container-filter'); } catch(e) { currentFilters.container = ''; }
        try { currentFilters.media_type = getMultiselectValue('media-type-filter'); } catch(e) { currentFilters.media_type = ''; }
        currentFilters.is_hybrid = document.getElementById('hybrid-filter-header') ? document.getElementById('hybrid-filter-header').value : '';
        try { currentFilters.secondary_hdr = getMultiselectValue('secondary-filter'); } catch(e) { currentFilters.secondary_hdr = ''; }
        currentFilters.status = document.getElementById('status-filter-header') ? document.getElementById('status-filter-header').value : '';
        try { currentFilters.resolution = getMultiselectValue('res-filter'); } catch(e) { currentFilters.resolution = ''; }
        const sizeFilter = document.getElementById('size-filter-header') ? document.getElementById('size-filter-header').value : '';
        const sizeParsed = parseFilterValue(sizeFilter);
        currentFilters.size_op = sizeParsed.op;
        currentFilters.size_val = sizeParsed.value;
        const bitFilter = document.getElementById('bit-filter-header') ? document.getElementById('bit-filter-header').value : '';
        const bitParsed = parseFilterValue(bitFilter);
        currentFilters.bit_op = bitParsed.op;
        currentFilters.bit_val = bitParsed.value;
        try { currentFilters.audio = getMultiselectValue('audio-filter'); } catch(e) { currentFilters.audio = ''; }
        currentFilters.sort = sortCol;
        currentFilters.order = sortOrder;
        
        // Build query string manually to ensure empty values are included if needed
        const params = new URLSearchParams();
        for (const [key, value] of Object.entries(currentFilters)) {
            if (value !== null && value !== undefined) {
                params.append(key, value.toString());
            }
        }
        window.location = '/download_csv?' + params.toString(); 
    }

    function exportJSON() {
        // Collect current filter values (same as exportCSV does)
        const currentFilters = { ...activeFilters };
        currentFilters.search = document.getElementById('search-bar') ? document.getElementById('search-bar').value : '';
        try { 
            currentFilters.category = getFormatFilterValue();
        } catch(e) { 
            currentFilters.category = ''; 
        }
        try { currentFilters.volume = getMultiselectValue('vol-filter'); } catch(e) { currentFilters.volume = ''; }
        try { currentFilters.profile = getMultiselectValue('profile-filter'); } catch(e) { currentFilters.profile = ''; }
        try { currentFilters.el = getMultiselectValue('el-filter'); } catch(e) { currentFilters.el = ''; }
        try { currentFilters.container = getMultiselectValue('container-filter'); } catch(e) { currentFilters.container = ''; }
        try { currentFilters.media_type = getMultiselectValue('media-type-filter'); } catch(e) { currentFilters.media_type = ''; }
        currentFilters.is_hybrid = document.getElementById('hybrid-filter-header') ? document.getElementById('hybrid-filter-header').value : '';
        try { currentFilters.secondary_hdr = getMultiselectValue('secondary-filter'); } catch(e) { currentFilters.secondary_hdr = ''; }
        currentFilters.status = document.getElementById('status-filter-header') ? document.getElementById('status-filter-header').value : '';
        try { currentFilters.resolution = getMultiselectValue('res-filter'); } catch(e) { currentFilters.resolution = ''; }
        const sizeFilter = document.getElementById('size-filter-header') ? document.getElementById('size-filter-header').value : '';
        const sizeParsed = parseFilterValue(sizeFilter);
        currentFilters.size_op = sizeParsed.op;
        currentFilters.size_val = sizeParsed.value;
        const bitFilter = document.getElementById('bit-filter-header') ? document.getElementById('bit-filter-header').value : '';
        const bitParsed = parseFilterValue(bitFilter);
        currentFilters.bit_op = bitParsed.op;
        currentFilters.bit_val = bitParsed.value;
        try { currentFilters.audio = getMultiselectValue('audio-filter'); } catch(e) { currentFilters.audio = ''; }
        currentFilters.sort = sortCol;
        currentFilters.order = sortOrder;
        
        // Build query string manually to ensure empty values are included if needed
        const params = new URLSearchParams();
        for (const [key, value] of Object.entries(currentFilters)) {
            if (value !== null && value !== undefined) {
                params.append(key, value.toString());
            }
        }
        window.location = '/download_json?' + params.toString(); 
    }
    
    async function runDatabaseMaintenance() {
        if (!confirm('Run database maintenance (VACUUM and ANALYZE)? This may take a few moments...')) {
            return;
        }
        
        const btn = document.getElementById('maintenance-db-btn');
        const originalText = btn.innerText;
        btn.disabled = true;
        btn.innerText = 'Optimizing...';
        
        try {
            const response = await fetch('/api/db/maintenance', { method: 'POST' });
            const result = await response.json();
            
            if (response.ok) {
                showToast('Database maintenance completed!');
            } else {
                showToast('Database maintenance failed');
                console.error('Maintenance failed:', result.message || 'Unknown error');
            }
        } catch (e) {
            console.error('Maintenance error:', e);
            showToast('Database maintenance failed');
        } finally {
            btn.disabled = false;
            btn.innerText = originalText;
        }
    }

    async function backfillMetadata() {
        if (!confirm('Backfill missing metadata (year, titles, season/episode, type) from .nfo and filename?')) {
            return;
        }
        try {
            showToast('Backfilling metadata...');
            const response = await fetch('/api/backfill_metadata', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ fill_blanks_only: true })
            });
            const result = await response.json();
            if (response.ok) {
                showToast(`Backfill complete (${result.updated || 0} updated)`);
                loadData();
            } else {
                showToast('Backfill failed');
                console.error('Backfill failed:', result.message || 'Unknown error');
            }
        } catch (e) {
            console.error('Backfill error:', e);
            showToast('Backfill failed');
        }
    }
    
    async function backupDatabase() {
        try {
            showToast('Preparing backup...');
            const response = await fetch('/api/backup', { method: 'POST' });
            if (response.ok) {
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `video_analyzer_backup_${new Date().toISOString().slice(0,10)}.zip`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                console.log('Backup downloaded successfully');
                showToast('Backup downloaded');
            } else {
                const error = await response.json();
                showToast('Backup failed');
                console.error('Backup failed:', error.message || 'Unknown error');
            }
        } catch (e) {
            console.error('Backup error:', e);
            showToast('Backup failed');
        }
    }
    
    async function restoreDatabase(fileInput) {
        const file = fileInput.files[0];
        if (!file) return;
        
        if (!file.name.toLowerCase().endsWith('.zip')) {
            showToast('Please select a ZIP file');
            fileInput.value = '';
            return;
        }
        
        if (!confirm('This will replace your current database and settings. Are you sure?')) {
            fileInput.value = '';
            return;
        }
        
        try {
            const formData = new FormData();
            formData.append('file', file);
            showToast('Restoring database...');
            
            const response = await fetch('/api/restore', {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            if (response.ok) {
                showToast(result.message || 'Database restored. Reloading...');
                fileInput.value = '';
                setTimeout(() => window.location.reload(), 1500);
            } else {
                showToast('Restore failed');
                console.error('Restore failed:', result.message || 'Unknown error');
                fileInput.value = '';
            }
        } catch (e) {
            console.error('Restore error:', e);
            showToast('Restore failed');
            fileInput.value = '';
        }
    }
    
    async function loadFilterPresetsList() {
        try {
            const response = await fetch('/api/filter_presets');
            if (response.ok) {
                const presets = await response.json();
                const select = document.getElementById('preset-select');
                if (select) {
                    select.innerHTML = '<option value="">Select preset...</option>';
                    for (const name of Object.keys(presets)) {
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = name;
                        select.appendChild(option);
                    }
                }
            }
        } catch (e) {
            console.error('Failed to load filter presets:', e);
        }
    }
    
    async function saveFilterPreset() {
        const nameInput = document.getElementById('preset-name-input');
        if (!nameInput) return;
        
        const presetName = nameInput.value.trim();
        if (!presetName) {
            alert('Please enter a preset name');
            return;
        }
        
        // Collect current filter values (same as exportCSV does)
        const currentFilters = { ...activeFilters };
        currentFilters.search = document.getElementById('search-bar') ? document.getElementById('search-bar').value : '';
        try { 
            currentFilters.category = getFormatFilterValue();
        } catch(e) { 
            currentFilters.category = ''; 
        }
        try { currentFilters.volume = getMultiselectValue('vol-filter'); } catch(e) { currentFilters.volume = ''; }
        try { currentFilters.profile = getMultiselectValue('profile-filter'); } catch(e) { currentFilters.profile = ''; }
        try { currentFilters.el = getMultiselectValue('el-filter'); } catch(e) { currentFilters.el = ''; }
        try { currentFilters.container = getMultiselectValue('container-filter'); } catch(e) { currentFilters.container = ''; }
        currentFilters.is_hybrid = document.getElementById('hybrid-filter-header') ? document.getElementById('hybrid-filter-header').value : '';
        try { currentFilters.secondary_hdr = getMultiselectValue('secondary-filter'); } catch(e) { currentFilters.secondary_hdr = ''; }
        currentFilters.status = document.getElementById('status-filter-header') ? document.getElementById('status-filter-header').value : '';
        try { currentFilters.resolution = getMultiselectValue('res-filter'); } catch(e) { currentFilters.resolution = ''; }
        const sizeFilter = document.getElementById('size-filter-header') ? document.getElementById('size-filter-header').value : '';
        const sizeParsed = parseFilterValue(sizeFilter);
        currentFilters.size_op = sizeParsed.op;
        currentFilters.size_val = sizeParsed.value;
        const bitFilter = document.getElementById('bit-filter-header') ? document.getElementById('bit-filter-header').value : '';
        const bitParsed = parseFilterValue(bitFilter);
        currentFilters.bit_op = bitParsed.op;
        currentFilters.bit_val = bitParsed.value;
        try { currentFilters.audio = getMultiselectValue('audio-filter'); } catch(e) { currentFilters.audio = ''; }
        try { currentFilters.video_source = getMultiselectValue('video-source-filter'); } catch(e) { currentFilters.video_source = ''; }
        try { currentFilters.source_format = getMultiselectValue('source-format-filter'); } catch(e) { currentFilters.source_format = ''; }
        try { currentFilters.video_codec = getMultiselectValue('video-codec-filter'); } catch(e) { currentFilters.video_codec = ''; }
        currentFilters.is_3d = document.getElementById('is-3d-filter-header') ? document.getElementById('is-3d-filter-header').value : '';
        try { currentFilters.edition = getMultiselectValue('edition-filter'); } catch(e) { currentFilters.edition = ''; }
        currentFilters.sort = sortCol;
        currentFilters.order = sortOrder;
        
        try {
            const response = await fetch('/api/filter_presets', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ name: presetName, filters: currentFilters })
            });
            
            const result = await response.json();
            if (response.ok) {
                nameInput.value = '';
                await loadFilterPresetsList();
                alert(result.message || 'Preset saved successfully');
            } else {
                alert('Failed to save preset: ' + (result.message || 'Unknown error'));
            }
        } catch (e) {
            console.error('Save preset error:', e);
            alert('Failed to save preset: ' + e.message);
        }
    }
    
    async function loadFilterPreset() {
        const select = document.getElementById('preset-select');
        if (!select || !select.value) {
            alert('Please select a preset to load');
            return;
        }
        
        try {
            const response = await fetch('/api/filter_presets');
            if (response.ok) {
                const presets = await response.json();
                const filters = presets[select.value];
                if (!filters) {
                    alert('Preset not found');
                    return;
                }
                
                // Apply filters (similar to how loadData applies filters from URL params)
                if (filters.search) document.getElementById('search-bar').value = filters.search;
                if (filters.category) setFormatFilterValue(filters.category);
                if (filters.volume) setMultiselectValue('vol-filter', filters.volume, true);
                if (filters.profile) setMultiselectValue('profile-filter', filters.profile, true);
                if (filters.el) setMultiselectValue('el-filter', filters.el, true);
                if (filters.container) setMultiselectValue('container-filter', filters.container, true);
                if (filters.media_type) setMultiselectValue('media-type-filter', filters.media_type, true);
                if (filters.is_hybrid !== undefined) document.getElementById('hybrid-filter-header').value = filters.is_hybrid;
                if (filters.secondary_hdr) setMultiselectValue('secondary-filter', filters.secondary_hdr, true);
                if (filters.status !== undefined) document.getElementById('status-filter-header').value = filters.status;
                if (filters.resolution) setMultiselectValue('res-filter', filters.resolution, true);
                if (filters.size_op && filters.size_val) {
                    const sizeVal = filters.size_op + filters.size_val;
                    document.getElementById('size-filter-header').value = sizeVal;
                }
                if (filters.bit_op && filters.bit_val) {
                    const bitVal = filters.bit_op + filters.bit_val;
                    document.getElementById('bit-filter-header').value = bitVal;
                }
                if (filters.audio) setMultiselectValue('audio-filter', filters.audio, true);
                if (filters.video_source) setMultiselectValue('video-source-filter', filters.video_source, true);
                if (filters.source_format) setMultiselectValue('source-format-filter', filters.source_format, true);
                if (filters.video_codec) setMultiselectValue('video-codec-filter', filters.video_codec, true);
                if (filters.is_3d !== undefined) document.getElementById('is-3d-filter-header').value = filters.is_3d;
                if (filters.edition) setMultiselectValue('edition-filter', filters.edition, true);
                if (filters.sort) sortCol = filters.sort;
                if (filters.order) sortOrder = filters.order;
                
                // Reload data with new filters
                resetAndLoad();
                alert('Preset loaded successfully');
            } else {
                alert('Failed to load presets');
            }
        } catch (e) {
            console.error('Load preset error:', e);
            alert('Failed to load preset: ' + e.message);
        }
    }
    
    async function deleteFilterPreset() {
        const select = document.getElementById('preset-select');
        if (!select || !select.value) {
            alert('Please select a preset to delete');
            return;
        }
        
        if (!confirm(`Are you sure you want to delete preset "${select.value}"?`)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/filter_presets/${encodeURIComponent(select.value)}`, {
                method: 'DELETE'
            });
            
            const result = await response.json();
            if (response.ok) {
                await loadFilterPresetsList();
                alert(result.message || 'Preset deleted successfully');
            } else {
                alert('Failed to delete preset: ' + (result.message || 'Unknown error'));
            }
        } catch (e) {
            console.error('Delete preset error:', e);
            alert('Failed to delete preset: ' + e.message);
        }
    }

    // Initialize column resize
    initColumnResize();
    
    // Initialize all multiselects
    const multiselectFilters = ['profile-filter', 'el-filter', 'vol-filter', 'container-filter', 'secondary-filter', 'res-filter', 'audio-filter'];
    multiselectFilters.forEach(filterId => {
        const wrapper = document.getElementById(`${filterId}-wrapper`);
        if (wrapper) {
            const button = wrapper.querySelector('.multiselect-button');
            const dropdown = wrapper.querySelector('.multiselect-dropdown');
            const buttonText = button.querySelector('span:first-child');
            multiselectState[filterId] = { open: false, button, dropdown, buttonText, options: {}, labelMap: {} };
            
            button.onclick = (e) => {
                e.stopPropagation();
                toggleMultiselect(filterId);
            };
        }
    });
    
    // Init - Check for ongoing scan first, then load data
    // Initial page load - ensure table loads with all files
    function initializePage() {
        clearFilters(false); // Clear all filters without reloading
        // Small delay to ensure DOM is ready and filters are cleared
        setTimeout(() => {
    loadData();
        }, 100);
    }
    
    fetch('/progress').then(r=>r.json()).then(d => {
        if(d.status === 'scanning') {
            // Reconnect to ongoing scan
            document.body.classList.add('scanning');
            scanStartTime = d.start_time || 0;
            if (scanStartTime > 0) {
                const srvDur = parseInt(d.last_duration.replace('s','')) || 0;
                const now = Date.now() / 1000;
                scanStartTime = now - srvDur;
            }
            // Still load initial data even if scan is in progress
            initializePage();
            poll(); // Start polling immediately
        } else {
            // No scan in progress, clear filters and load data normally
            initializePage();
        }
    }).catch(e => {
        console.error("Failed to check progress:", e);
        // Fallback to normal load
        initializePage();
    });
    
    setInterval(updateLogs, 2000);
    setInterval(() => { if(document.body.classList.contains('scanning') && scanStartTime) { const diff = Math.floor((Date.now() / 1000) - scanStartTime); document.getElementById('stat-duration').innerText = formatDuration(diff); } }, 1000);
</script>
</body>
</html>